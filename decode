#!/usr/bin/env perl
#
# Decodes:
# - LPP send and receive bus traces. Note that TET.pl must be run on the log first.
# - Time stamps in LPP traces. Note that TET.pl must be run on the log first.
# - MAC, RLC and PDCP PDU traces and GTP-u traces
# - NC send and receive bus traces. Some BBMC send and receive bus traces.
# - CDA ziplog entries to show signal names and decoded CM memory (ziplog_verbose)
# - Data for any known struct using interactive mode or the node's coli command 'readcm'
# - RDR measurements (only when if model is used as input)
#
# Created by:
#   Henrik Ahlander, 2009-03-03
#
# Updated by:
#   See clearcase history at /vobs/erbs/ext/tools/flexTools/decode
#

use strict;

$| = 1;  # no buffering

my $SCRIPT_VERSION_NR = 17;  # integer, step this to force all users to update cache
my @arguments;
my @argumentUsed;
my %settings;
$settings{searchpaths} = "/vobs/erbs/bbmc;/vobs/erbs/elib;/vobs/erbs/up;/vobs/erbs/upc;/vobs/erbs/nc;/vobs/rbs/hw/bcp/atf/A4CI/include;".
                         "/vobs/rbs/hw/nci_comm/deliv/ifu/ricm-cdci/inc;/vobs/rbs/hw/ru_deliveries/signal_files;/vobs/crbs/clib;/vobs/crbs/bbi/am;".
			 "/vobs/crbs/bbi/fm;/vobs/crbs/bbi/iw;/vobs/crbs/bbi/legacy";
$settings{scriptlocation} = "/vobs/erbs/ext/tools/flexTools/decode";
$settings{cachepath} = "/vobs/erbs/ext/tools/flexTools/decode_cache.data";
$settings{signalfile} = "/vobs/erbs/elib/bbBaseBl/commonLU/inc/bbbase_com_signals.sig";
$settings{tempstorage} = "/vobs/erbs/ext/tools/flexTools/decode_temp";
$settings{compactlevel} = 4;
$settings{ifmodelcachepath} = "decode_cache.data";
$settings{ifmodelpath} = "ifModelLm.xml";
$settings{mtdpath_dul3} = "lteRbsBbMtdInfoDul3.xml";
$settings{mtdpath_dus41} = "lteRbsBbMtdInfoDus41.xml";

my %structAttributes;
my %typeDef;
my $prefixNr = 0;
my %prefixName;
my %signalStruct;
my %signalName;
my $signalStructName = "";
my $signalData;
my $signalDataPlatform;
my $signalDataLength;
my $signalDataLengthToUse = 0;
my $signalTraceLine;
my %signalFormula;  # used when reading from ifmodel
my %signalValue;    # used when reading from ifmodel
my $pduBitData;
my $pduAttributeNr;
my %enumValue;
my %arraySizeVariabelHard;
my %arraySizeVariabelSoft;
my %arrayDisplayVariabel;
my %displayVariabelAlsoAsHex;
my %decodeAttributeAsPdu;
my %savedAttributeValue;
my %savedAttributeValueFullPath;
my %savedDecodedAttributeFullPath;
my $decodedDataText;
my $currentStructStructure = "";
my $latestRadioTimeStamp = "";
my $latestBfn = "";
my $latestSfn = "";
my $latestSf = "";
my %savedStructStructure = "";
my %savedStructData;
my $signalDataEmptyWarningDisplayed;
my %isUnion;
my %unionAttributeDisplaySetting;
my %unionAttributeDisplayed;
my @inputDataLines;
my %cmMemoryPtrUsed;
my %stridName;
my $stridThreadsInGroup = 6; # default value 
my $FI; # file input handle
my $FO; # file output handle
my $FOTEXT; # file output handle for signal data in text format
my $power2_15 = 2**15;
my $power2_31 = 2**31;
my %rdrStruct;

setStandaloneSettings();
saveArguments(@ARGV);
handleArguments();
handleCommand();


sub setStandaloneSettings
{
  # <standalone replace settings start>
  $settings{standalone} = 0;
  # <standalone replace settings end>
}


sub handleArguments
{
  # check these flags first
  $settings{showhexdata} = isFlagSet("hex");
  $settings{csv} = isFlagSet("csv");
  $settings{textonly} = isFlagSet("textonly");
  $settings{text} = isFlagSet("text");
  $settings{showpadding} = isFlagSet("padding", 3);

  if(isFlagSet("help", 1))
  {
    printUsage();
    exit;
  }

  $settings{ifpath} = getFlagValue("if");
  if($settings{ifpath} ne "")
  {
    $settings{ifpath} .= "/" unless $settings{ifpath} =~ /\/$/;
    $settings{ifmodelpath} = "$settings{ifpath}ifModelLm.xml";
    $settings{mtdpath_dul3} = "$settings{ifpath}lteRbsBbMtdInfoDul3.xml";
    $settings{mtdpath_dus41} = "$settings{ifpath}lteRbsBbMtdInfoDus41.xml";
    $settings{useifmodel} = 1;
  }

  if(!$settings{standalone})
  {
    $settings{update} = isFlagSet("update", 1);
    $settings{force} = isFlagSet("force", 1);
  }
  $settings{type} = isFlagSet("type", 1);
  $settings{position} = isFlagSet("position", 1);
  $settings{compressarrays} = !isFlagSet("nocompress", 3);
  $settings{decoderadiotime} = !isFlagSet("notime", 3);
  $settings{showallelements} = isFlagSet("all", 1);
  $settings{debug} = isFlagSet("debug");
  if(!$settings{standalone})
  {
    $settings{generate} = getFlagValue("generate", 1);
  }
  $settings{dct2000} = getFlagValue("dct2000", 1);
  $settings{rohcprofile2} = isFlagSet("rohcprofile2", 1);

  $settings{buildcache} = "";
  if(isFlagSet("buildcache"))
  {
    while(my $argument = getNextNonFlagArgument())
    {
      $settings{buildcache} .= "$argument ";
    }
  }

  my $compactLevel = getFlagValue("level", 1);
  if($compactLevel =~ /^\d+$/)
  {
    $settings{compactlevel} = $compactLevel;
  }
  elsif($compactLevel ne "")
  {
    print STDERR "Incorrect usage. Level not a number: $compactLevel\n";
    printUsage();
    exit 1;
  }

  $settings{interactive} = isFlagSet("interactive", 1);
  $settings{struct} = getFlagValue("struct", 1);
  if(!$settings{standalone})
  {
    $settings{readcfiles} = isFlagSet("cfiles", 1);
    $settings{scanforfiles} = getFlagValue("scanforfiles");
  }

  if($settings{buildcache} eq "" && $settings{scanforfiles} eq "")
  {
    while(my $argument = getNextNonFlagArgument())
    {
      if(!(-f $argument))
      {
        print STDERR "Incorrect usage. File not found: $argument\n";
        printUsage();
        exit 1;
      }
      $settings{files} .= "$argument ";
    }
  }

  if(!isAllArgumentsUsed())
  {
    print STDERR "Incorrect usage. Incorrect argument(s): ".(getUnusedArguments())."\n";
    printUsage();
    exit 1;
  }
}


sub handleCommand
{
  if($settings{useifmodel})
  {
    # use data from interface model
    loadIfModel();
    hardCodedSignalAndStructRelations();
  }
  else
  {
    # use data from vobs

    if($settings{scanforfiles} ne "")
    {
      findHeaderAndSignalFiles($settings{scanforfiles});
      exit 0;
    }
    elsif($settings{buildcache} ne "")
    {
      readHeaderAndSignalFiles($settings{buildcache});  

      print STDERR "\nMatching signals with structs";
      readSignalNumbers();
      guessSignalAndStructRelations();
      hardCodedSignalAndStructRelations();

      print STDERR "\nSaving cache...\n";
      saveCache($settings{cachepath}, "");

      exit 0;
    }

    my $cacheRead = 0;
    if(!$settings{update})
    {
      if(!$settings{standalone})
      {
        print STDERR "Note: Each time you modify your config spec you must add the -u flag to update cached signals and structs\n";
      }
      $cacheRead = loadCache($settings{cachepath}, "");
    }

    if(!$cacheRead || $settings{update})
    {
      my $startTime = time;
      print STDERR "Collecting information about signals and structs from the vobs (if this operation takes longer than 5 minutes, try running the command from one of the terminal servers with faster clearcase access):\n";
      if($settings{readcfiles})
      {
        print STDERR "Finding .h, .sig, .c and .cc files\n";
      }
      else
      {
        print STDERR "Finding .h and .sig files\n";
      }
      my @files;
      updateCache($settings{searchpaths}, \@files);

      my $totalTime = time - $startTime;
      print STDERR sprintf("\nUpdate done in %d min %d sec.\n", $totalTime / 60, $totalTime % 60);
    }
  }

  hardCodedStructData();
  if($settings{generate})
  {
    generateStandAloneVersion();
    return;
  }
  
  if($settings{dct2000} ne "")
  {
    if($settings{dct2000} !~ /\.out/i) {$settings{dct2000} .= ".out";}
    open(DCTFILE, ">$settings{dct2000}") or die "Could not save dct2000 file $settings{dct2000}";
    print DCTFILE "Session Transcript (format 3.1, release 10.6 on ukeng7, Linux 2.6.8-24-smp i686)\n";
    print DCTFILE "January 1, 2010     00:00:00.0000\n";
  }
  
  if($settings{interactive})
  {
    decodeInteractive();
  }
  elsif($settings{files} ne "")
  {
    decodeFiles();
  }
  else
  {
    decodeStdin();
  }
  
  if($settings{dct2000} ne "")
  {
    close DCTFILE;
    print "Saved $settings{dct2000}.\n";
  }
}


# ------------- Preparations ------------------------------------------------------------------------------------


sub hardCodedStructData
{
  # Some structs have a complex structure with variable number of elements. If the last attribute of a struct
  # is variable and the second last attribute is named something with noof, nrof, size, numberof or length it will be
  # automatically understood. Otherwise this can be defined here:
  #
  # arrayDisplayVariabel    defines the name of the argument, which holds the number of elements in the array 
  #                         that should be displayed
  # arraySizeVariabelHard   defines the name of the argument, which holds the number of elements in the array
  #                         that is allocated in the struct.
  # arraySizeVariabelSoft   defines the name of the argument, which holds the number of elements in the array
  #                         that is allocated in the struct (but minimum 1 is always expected).
  # decodeAttributeAsPdu    defines if the rest of the signal data should be decoded as an MAC, RLC or PDCP PDU
  # unionAttributeDisplaySetting   defines how many of each struct in this union that should be seen, defined in
  #                                the format "structName:numberOfElements,structName:numberOfElements,..."

  # BbmcBbCellMeDciCellSetupReqS
  $arrayDisplayVariabel{"BbmcBbCellMeDciCellSetupReqS, antennasTx"} = "noOfAntennasTx";
  $arrayDisplayVariabel{"BbmcBbCellMeDciCellSetupReqS, antennasRx"} = "noOfAntennasRx";
  $arrayDisplayVariabel{"BbmcBbCellMeDciCellSetupReqS, btSettingsList"} = "nrOfBtSettings";

  # UpUlL1PeEiAllocationIndS
  $arraySizeVariabelHard{"UpUlL1PeEiAllocationIndS, ulL1PuschAllocationStructList"} = "noOfPuschAllocations";
  $arraySizeVariabelHard{"UpUlL1PeEiAllocationIndS, ulL1PucchAllocationStructList"} = "noOfPucchAllocations";
  $arraySizeVariabelHard{"UpUlL1PeEiAllocationIndS, ulL1SrsAllocationStructList"} = "noOfSrsAllocations";
  $arraySizeVariabelHard{"UpUlL1PeEiAllocationIndS, ulL1Srs8txrxAllocationStructList"} = "noOfSrs8txrxAllocations";
  $arrayDisplayVariabel{"UpUlL1PeEiAllocationIndS, ulL1PuschAllocationStructList"} = "noOfPuschAllocations";
  $arrayDisplayVariabel{"UpUlL1PeEiAllocationIndS, ulL1PucchAllocationStructList"} = "noOfPucchAllocations";
  $arrayDisplayVariabel{"UpUlL1PeEiAllocationIndS, ulL1SrsAllocationStructList"} = "noOfSrsAllocations";
  $arrayDisplayVariabel{"UpUlL1PeEiAllocationIndS, ulL1Srs8txrxAllocationStructList"} = "noOfSrs8txrxAllocations";

  # UpUlMacPeCiUeUlMacCtrlInfoS
  $arraySizeVariabelSoft{"UpUlMacPeCiUeUlMacCtrlInfoS, sduInfoList"} = "nrOfSduInfos";
  $arraySizeVariabelSoft{"UpUlMacPeCiUeUlMacCtrlInfoS, macCtrlElementList"} = "nrOfMacCtrlElements";
  $arrayDisplayVariabel{"UpUlMacPeCiUeUlMacCtrlInfoS, sduInfoList"} = "nrOfSduInfos";
  $arrayDisplayVariabel{"UpUlMacPeCiUeUlMacCtrlInfoS, macCtrlElementList"} = "nrOfMacCtrlElements";
  
  # Structs that contains RLC PDUs
  $decodeAttributeAsPdu{"UpDlRlcPeRlcStatusForDlTrafficIndS", "pdu"} = "rlcdrbpdu";
  $decodeAttributeAsPdu{"UpDlRlcPeRlcStatusForUlTrafficIndS", "pdu"} = "rlcdrbpdu";
  
  # Structs that contains PDCP PDUs
  $decodeAttributeAsPdu{"UpUlRlcPeUlDataIndS", "pdcpPdu"} = "pdcpdrbpdu";

  # Structs that contains RRC PDUs
  $decodeAttributeAsPdu{"UpUlRlcPeRrcCUlComDataIndS", "rrcPdu"} = "rrcpdu";

  # UpUlMacPeCiUlL1Meas2UlIndS old name, kept for a while for backwards compability
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Meas2UlIndS, reportList"} = "totalNrOfReports";
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Meas2UlIndS, srsRxPowerReport"} = "nrOfSrsReports";
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Meas2UlIndS, puschRxPowerPerPrb"} = "nrOfRxPowerPerPrb";
  $arrayDisplayVariabel{"UpUlMacPeCiUlL1Meas2UlIndS, reportList"} = "totalNrOfReports";
  $arrayDisplayVariabel{"UpUlMacPeCiUlL1Meas2UlIndS, srsRxPowerReport"} = "nrOfSrsReports";
  $arrayDisplayVariabel{"UpUlMacPeCiUlL1Meas2UlIndS, puschRxPowerPerPrb"} = "nrOfRxPowerPerPrb";
  # old names, kept for a while for backwards compability
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Meas2UlIndS, doNotUse0"} = "nrOfSrsReports";
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Meas2UlIndS, doNotUse1"} = "nrOfRxPowerPerPrb";
  $arrayDisplayVariabel{"UpUlMacPeCiUlL1Meas2UlIndS, doNotUse0"} = "nrOfSrsReports";
  $arrayDisplayVariabel{"UpUlMacPeCiUlL1Meas2UlIndS, doNotUse1"} = "nrOfRxPowerPerPrb";

  # UpUlMacPeCiUlL1Measrprt2UlIndS
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Measrprt2UlIndS, srsRxPowerReportList"} = "nrOfSrsReports";
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Measrprt2UlIndS, puschRxPowerPerPrbList"} = "nrOfRxPowerPerPrb";
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Measrprt2UlIndS, puschReportList"} = "nrOfPuschReports";
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Measrprt2UlIndS, pucchSrReportList"} = "nrOfPucchSrReports";
  $arrayDisplayVariabel{"UpUlMacPeCiUlL1Measrprt2UlIndS, srsRxPowerReportList"} = "nrOfSrsReports";
  $arrayDisplayVariabel{"UpUlMacPeCiUlL1Measrprt2UlIndS, puschRxPowerPerPrbList"} = "nrOfRxPowerPerPrb";
  $arrayDisplayVariabel{"UpUlMacPeCiUlL1Measrprt2UlIndS, puschReportList"} = "nrOfPuschReports";
  $arrayDisplayVariabel{"UpUlMacPeCiUlL1Measrprt2UlIndS, pucchSrReportList"} = "nrOfPucchSrReports";

  # UpUlMacPeCiUlL1Meas2DlIndS -- old names , kept for a while for backward compability for wp2169
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Meas2DlIndS, pucchReport"} = "nrOfPucchReports";
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Meas2DlIndS, puschReport"} = "nrOfPuschReports";
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Meas2DlIndS, srsReportList"} = "nrOfSrsReports";
  # old name, kept for a while for backwards compability
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Meas2DlIndS, reportList"} = "totalNrOfReports";

  # UpUlMacPeCiUlL1Measrprt2DlIndS since wp2169 
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Measrprt2DlIndS, pucchReportList"} = "nrOfPucchReports";
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Measrprt2DlIndS, puschReportList"} = "nrOfPuschReports";
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Measrprt2DlIndS, srsReportList"} = "nrOfSrsReports";
 
  # UpUlMacPeCiUlL1Harqfdbk2DlIndS since wp2169 
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Harqfdbk2DlIndS, pucchHarqReportList"} = "nrOfPucchReports";
  $arraySizeVariabelHard{"UpUlMacPeCiUlL1Harqfdbk2DlIndS, puschHarqReportList"} = "nrOfPuschReports";
 
  # UpUlL1PeUeSrsS
  $arrayDisplayVariabel{"UpUlL1PeUeSrsS, symbolInfo"} = "nrOfSymbols";

  # Structs with unions where it is defined in other attributes how many of each type that should be displayed
  $unionAttributeDisplaySetting{"UpUlMacPeCiMeasDlReportU"} = "puschReport:nrOfPuschReports,pucchReport:nrOfPucchReports";
  $unionAttributeDisplaySetting{"UpUlMacPeCiMeasUlReportU"} = "puschReport:nrOfPuschReports,pucchSrReport:nrOfPucchSrReports";

  # UpDlMacPeCiPdcchIndS
  $arrayDisplayVariabel{"UpDlMacPeCiPdcchIndS, pdcch"} = "totalNrOfDci";
  $arraySizeVariabelSoft{"UpDlMacPeCiPdcchIndS, pdcch"} = "totalNrOfDci";
  
  # UpUlCellPeCiCellStatusReportIndS
  $arraySizeVariabelSoft{"UpUlCellPeCiCellStatusReportIndS, puschIntNoisePwrPerPrb"} = "ulPrbBandwidth";

  # UpUlMacPeCiUlHarqBuffReleaseIndS
  $arraySizeVariabelHard{"UpUlMacPeCiUlHarqBuffReleaseIndS, ulHarqBuffReleaseList"} = "nrOfUlHarqBuffRelease";
  $arraySizeVariabelHard{"UpUlMacPeCiUlHarqBuffReleaseIndS, inSyncHarqBuffReleaseList"} = "nrOfInSyncHarqBuffRelease";
  
  # General rules to display bbUeRef variables also as hex format. Only applicable on U32 (update in decodeStruct needed for
  # wider support). U64 are always shown also in hex format.
  $displayVariabelAlsoAsHex{"clientRef"} = 1;
  $displayVariabelAlsoAsHex{"sessionRef"} = 1;
  $displayVariabelAlsoAsHex{"bbUeRef"} = 1;
  
  # these types are handled by the script
  $typeDef{BOOL} = "int";
  $typeDef{SIGSELECT} = "S32";
  delete $typeDef{S16};
  delete $typeDef{S32};
  delete $typeDef{S64};
  delete $typeDef{U8};
  delete $typeDef{U16};
  delete $typeDef{U32};
  delete $typeDef{U64};
  delete $typeDef{CHAR};
}


sub hardCodedSignalAndStructRelations
{
  # Which struct a signal is using is guessed by the script itself. But if any signal is using the wrong struct
  # the right struct can be hard coded here. Example:
  #$signalStruct{UP_DLMACPE_CI_PDCCH_IND} = "DLMACPE_pdcchIndS";
  $signalName{16841984} = "A4CI_CONN_ESTABLISH_REQ";
  $signalStruct{A4CI_CONN_ESTABLISH_REQ} = "a4ci_connEstablishReqS";
  $signalName{16841985} = "A4CI_CONN_ESTABLISH_CFM";
  $signalStruct{A4CI_CONN_ESTABLISH_CFM} = "a4ci_connEstablishCfmS";
  $signalName{16841986} = "A4CI_CONN_ESTABLISH_REJ";
  $signalStruct{A4CI_CONN_ESTABLISH_REJ} = "a4ci_connEstablishRejS";
  $signalName{16841987} = "A4CI_DATA_FWD";
  $signalStruct{A4CI_DATA_FWD} = "a4ci_dataFwdS";
  $signalName{16841988} = "A4CI_DATA_REQ";
  $signalStruct{A4CI_DATA_REQ} = "a4ci_dataReqS";
  $signalName{16841989} = "A4CI_DATA_CFM";
  $signalStruct{A4CI_DATA_CFM} = "a4ci_dataCfmS";
  $signalName{16841990} = "A4CI_DATA_REJ";
  $signalStruct{A4CI_DATA_REJ} = "a4ci_dataRejS";

  $signalStruct{DL_DATA_IND} = "PAP_ETH_extDataIndS";
}


# ------------- Read signals and structs from if model --------------------------------------------------------------------


sub loadIfModel
{
  if(!-e $settings{ifmodelpath})
  {
    print STDERR "Cannot open $settings{ifmodelpath}. This file can be downloaded from the node, location /c/loadmodules_norepl/CXC1728332%7_*/xml/ifModelLm.xml. Save the file in the same directory as the decode script.\n";
    exit 1;
  }
  
  if(-e $settings{mtdpath_dul3} && -e $settings{mtdpath_dus41})
  {
    print STDERR "Both lteRbsBbMtdInfoDul3.xml and lteRbsBbMtdInfoDus41.xml are found. Use only the one that corresponds to the HW the trace is taken from.\n";
    exit 1;
  }
  elsif(-e $settings{mtdpath_dul3})
  {
    $settings{mtdpath} = $settings{mtdpath_dul3};
  }  
  elsif(-e $settings{mtdpath_dus41})
  {
    $settings{mtdpath} = $settings{mtdpath_dus41};
  }
  else
  {
    print STDERR "Cannot open $settings{mtdpath_dul3} or $settings{mtdpath_dus41}. These files can be downloaded from the node:\n";
    print STDERR "Location DUL3: /c/loadmodules_norepl/CXC1730062%7_*/xml/lteRbsBbMtdInfoDul3.xml\n";
    print STDERR "Location DUS41: /c/loadmodules_norepl/CXC1731083%18_*/xml/lteRbsBbMtdInfoDus41.xml\n";
    print STDERR "Only download the file that corresponds to the HW the trace is taken from. Save the file in the same directory as the decode script.\n";
    exit 1;
  }
  
  # create a unique id based on file size used to determine if cache must be updated
  my $uniqueId = (-s $settings{ifmodelpath}).".".(-s $settings{mtdpath});
  
  if(!$settings{update} && loadCache($settings{ifmodelcachepath}, $uniqueId))
  {
    # use cached data
  }
  else
  {
    # read data from file
    print STDERR "Reading interface model files";
    readIfModelFile($settings{ifmodelpath});
    readMtdFile($settings{mtdpath});
  
    # try to resolve unknown signal and struct relations
    print STDERR "\nMatching signals with structs";
    guessSignalAndStructRelations();
    print STDERR "\n";

    print STDERR "\nSaving cache...\n";
    saveCache($settings{ifmodelcachepath}, $uniqueId);
  }

  if($settings{debug})
  {
    print "debug unresolved signals:\n";
    foreach my $signalName (sort keys %signalFormula)
    {
      my $hex = $signalValue{$signalName} !~ /\d/ ? "-" : sprintf("0x%x", $signalValue{$signalName});
      print "$signalName, $hex, $signalFormula{$signalName}, $signalStruct{$signalName}\n";
    }
  }

  $settings{cachepath} = $settings{ifmodelcachepath};
}


sub readIfModelFile
{
  my ($fileName) = @_;

  my $structName = "";
  my $structAttributes = "";
  my $enumName = "";
  my $rdrId = "";
  my %tempRdrName;
  my %tempRdrFragment;
  my %tempRdrNumber;
  my %tempRdrMeasStruct;
  my %tempRdrReportStruct;
  my $rdrStruct = "";
  my $tag = "";
  my $attributes = "";
  my $signalName = "";
  my $signalNumber = "";
  my $stereoType = "";
  my $attributeName = "";
  my $attributeType = "";
  my $attributeReference = "";
  my $attributeStereoType = "";
  my $attributeSubStereoType = "";
  my $attributeLength = "";
  my $attributeLengthElement = "";
  my $constantName = "";
  my $constantValue = "";
  my $enumType = "";
  my $enumSymbolName = "";
  my $enumSymbolValue = "";
  my $typeDefName = "";
  my $typeDefType = "";
  my $sigBaseName = "";
  my $sigBaseValue = "";
  my $lineData;
  my $counter = 0;

  open(FI, "<$fileName") or die "Could not open $fileName";
  while($lineData = <FI>)
  {
    if($lineData =~ /^\s*?<\/(\w+)/)
    {
      $tag = $1;
      #print "end tag: $1\n";
      if($tag eq "signal" || $tag eq "struct" || $tag eq "union")
      {
        if($structName ne "")
        {
          $structAttributes{$structName} = $structAttributes;
          $structAttributes = "";
          $structName = "";
        }
      }
      elsif($tag eq "enum")
      {
        $enumName = "";
      }
    }
    elsif($lineData =~ /^\s*?<(\w+)(.*)>/)
    {
      ($tag, $attributes) = ($1, $2);
      #print "tag: $tag, attributes: $attributes\n";
      if($tag eq "signal")
      {
        $signalName = ($attributes =~ / osename=\"(.*?)\"/) ? $1 : "";
        $structName = ($attributes =~ / osestruct=\"(.*?)\"/) ? $1 : "";
        $signalStruct{$signalName} = $structName;
        $signalNumber = ($attributes =~ / signalno=\"(.*?)\"/) ? $1 : -1;
        $signalNumber =~ s/(0[xX][0-9A-Fa-f]+)L?/hex($1)/ge;
        $signalNumber =~ s/(\d+)UL/$1/ge;
        tryResolveSignalFormula($signalName, $signalNumber);
        #print "====> signal: $signalName - $structName - $signalNumber\n";
      }
      elsif($tag eq "struct")
      {
        $structName = ($attributes =~ / osename=\"(.*?)\"/) ? $1 : "";
        $stereoType = ($attributes =~ / stereotype=\"(.*?)\"/) ? $1 : "";
        $rdrId = ($attributes =~ / rdrid=\"(.*?)\"/) ? $1 : "";
        if($stereoType eq "RdrMeasurementTop")
        {
          if($rdrId ne "NA")
          {
            $tempRdrMeasStruct{$rdrId} = $structName;
          }
        }
        elsif($stereoType eq "RdrFragmentTop")
        {
          $rdrStruct = ($attributes =~ / rdrmeasstruct=\"(.*?)\"/) ? $1 : "";
          if($rdrStruct ne "NA")
          {
            $tempRdrFragment{$structName} = "${rdrStruct}S,$rdrId";
          }
        }
        #print "====> struct: $structName, $stereoType, $rdrId, $rdrStruct\n";
      }
      elsif($tag eq "union")
      {
        $structName = ($attributes =~ / osename=\"(.*?)\"/) ? $1 : "";
        $isUnion{$structName} = 1;
        #print "====> struct: $structName\n";
      }
      elsif($tag eq "element")
      {
        $attributeName = ($attributes =~ / name=\"(.*?)\"/) ? $1 : "";
        $attributeType = ($attributes =~ / type=\"(.*?)\"/) ? $1 : "";
        $attributeStereoType = ($attributes =~ / stereotype=\"(.*?)\"/) ? $1 : "";
        $attributeSubStereoType = ($attributes =~ / substereotype=\"(.*?)\"/) ? $1 : "";
        if($attributeStereoType eq "struct" || $attributeSubStereoType eq "struct" ||
           $attributeStereoType eq "signal" || $attributeSubStereoType eq "signal")
        {
          $attributeType .= "S";
        }
        elsif($attributeStereoType eq "union" || $attributeStereoType eq "internal_chosen_union" ||
              $attributeSubStereoType eq "union" || $attributeSubStereoType eq "internal_chosen_union")
        {
          $attributeType .= "U";
        }
        elsif($attributeStereoType eq "enum" || $attributeSubStereoType eq "enum")
        {
          $attributeType .= "E";
          $typeDef{$attributeType} = "enum";
        }
        $attributeReference = ($attributes =~ / reference=\"(.*?)\"/) ? $1 : "";
        if($attributeReference eq "by_cmref")
        {
          $attributeType = "__cm ${attributeType}*";
        }
        $attributeLength = ($attributes =~ / length=\"(.*?)\"/) ? $1 : "";
        $attributeLengthElement = ($attributes =~ / lengthelement=\"(.*?)\"/) ? $1 : "";
        $attributeLengthElement =~ s/.+\.(.+)/$1/;
	if($attributeType =~ /(.*):(\d+)/)
        {
          $attributeType = $1;
          my $bitLength = $2;
          $structAttributes .= "$attributeType:$bitLength=\.$attributeName,";
        }
        elsif($attributeLength ne "")
        {
          $structAttributes .= "$attributeType=\.$attributeName\[$attributeLength\],";
        }
        elsif($attributeLengthElement ne "")
        {
          $structAttributes .= "$attributeType=\.$attributeName\[$attributeLengthElement\],";
        }
        else
        {
          $structAttributes .= "$attributeType=\.$attributeName,";
        }
        if($attributeType =~ /rdr/i)
        {
          $tempRdrReportStruct{$attributeType} = $structName;
        }
        #print "====> structattribute: $attributeName - $attributeType - $attributeLength\n";
      }
      elsif($tag eq "constant")
      {
        $constantName = ($attributes =~ / name=\"(.*?)\"/) ? $1 : "";
        $constantValue = ($attributes =~ / value=\"(.*?)\"/) ? $1 : "";
        $typeDef{$constantName} = $constantValue;
        #print "====> constant: $constantName - $constantValue\n";
      }
      elsif($tag eq "enum")
      {
        $enumName = ($attributes =~ / osename=\"(.*?)\"/) ? $1 : "";
        $enumType = ($attributes =~ / type=\"(.*?)\"/) ? $1 : "";
        $typeDef{$enumName} = "enum";
        #print "====> enum: $enumName - $enumType\n";
      }
      elsif($tag eq "typedef")
      {
        $typeDefName = ($attributes =~ / name=\"(.*?)\"/) ? $1 : "";
        $typeDefType = ($attributes =~ / type=\"(.*?)\"/) ? $1 : "";
        $typeDef{$typeDefName} = $typeDefType;
        #print "====> typeDef: $typeDefName - $typeDefType\n";
      }
      elsif($tag eq "symbol")
      {
        $enumSymbolName = ($attributes =~ / name=\"(.*?)\"/) ? $1 : "";
        $enumSymbolValue = ($attributes =~ / value=\"(.*?)\"/) ? $1 : "";
        $enumValue{$enumName, $enumSymbolValue} = $enumSymbolName;
        if($enumName eq "ElibRdrMeasurementTypeE")
        {
          $tempRdrName{$enumSymbolValue} = $enumSymbolName;
        }
        #print "====> enumsymbol: $enumSymbolName - $enumSymbolValue\n";
      }
      elsif($tag eq "sigbase")
      {
        $sigBaseName = ($attributes =~ / name=\"(.*?)\"/) ? $1 : "";
        $sigBaseValue = ($attributes =~ / value=\"(.*?)\"/) ? $1 : "";
        $sigBaseValue =~ s/(0[xX][0-9A-Fa-f]+)L?/hex($1)/ge;
        $sigBaseValue =~ s/(\d+)UL/$1/ge;
        tryResolveSignalFormula($sigBaseName, $sigBaseValue);
        #print "====> sigbase: $sigBaseName - $sigBaseValue\n";
      }
    }
    else
    {
      #print "unknown: $lineData\n";
    }

    print STDERR "." if (($counter++ % 6000) == 0);
  }
  close FI;

  if($structName ne "")
  {
    $structAttributes{$structName} = $structAttributes;
  }
  
  # resolve rdr struct and number mapping
  my ($rdrNumber, $rdrName, $rdrMeasStruct, $rdrFragmentStruct, $rdrMeasStructAndFragmentType, $rdrFragmentType, $rdrFragmentNumber);
  my %tempRdrStruct;
  while(($rdrNumber, $rdrName) = each %tempRdrName)
  {
    $rdrMeasStruct = $tempRdrMeasStruct{$rdrName};
    if(defined $rdrMeasStruct)
    {
      $tempRdrNumber{$rdrMeasStruct} = $rdrNumber;
    }
  }
  while(($rdrFragmentStruct, $rdrMeasStructAndFragmentType) = each %tempRdrFragment)
  {
    if($rdrMeasStructAndFragmentType =~ /^(.*?),(.*?)$/)
    {
      ($rdrMeasStruct, $rdrFragmentType) = ($1, $2);
      $rdrNumber = $tempRdrNumber{$rdrMeasStruct};
      if(!defined $rdrNumber)
      {
        $rdrMeasStruct = $tempRdrReportStruct{$rdrMeasStruct};
        if(defined $rdrMeasStruct)
        {
          $rdrNumber = $tempRdrNumber{$rdrMeasStruct};
        }
      }

      if(defined $rdrNumber)
      {
        $rdrFragmentNumber = $typeDef{$rdrFragmentType};
        if(defined $rdrFragmentNumber)
        {
          $rdrStruct{$rdrNumber, $rdrFragmentNumber} = $rdrFragmentStruct;
        }
      }
    }
  }

  # try to resolve unresolved signal formulas
  my $nrOfSignalsRemainingBefore = 0;
  my $nrOfSignalsRemainingAfter = scalar keys %signalFormula;
  do
  {
    $nrOfSignalsRemainingBefore = $nrOfSignalsRemainingAfter;
    foreach my $signalName (sort keys %signalFormula)
    {
      tryResolveSignalFormula($signalName, $signalFormula{$signalName});
    }
    $nrOfSignalsRemainingAfter = scalar keys %signalFormula;
  } while($nrOfSignalsRemainingAfter < $nrOfSignalsRemainingBefore);

  # these types are handled by the script
  $typeDef{BOOL} = "int";
  $typeDef{SIGSELECT} = "S32";
  delete $typeDef{S16};
  delete $typeDef{S32};
  delete $typeDef{S64};
  delete $typeDef{U8};
  delete $typeDef{U16};
  delete $typeDef{U32};
  delete $typeDef{U64};
  delete $typeDef{CHAR};
}


sub tryResolveSignalFormula
{
  my ($name, $value) = @_;

  if($value =~ /([A-Z][A-Z0-9_]+)/)
  {
    my $signal = $1;
    while($signal ne "" && $signalValue{$signal} ne "")
    {
      $value =~ s/$signal/$signalValue{$signal}/g;
      $signal = ($value =~ /([A-Z][A-Z0-9_]+)/) ? $1 : "";
    }
  }

  if($value =~ /[A-Za-z]/)   # unresolved variable remains
  {
    $signalFormula{$name} = $value;
  }
  else
  {
    $value = eval($value);
    $signalValue{$name} = $value;
    $signalName{$value} = $name;
    delete($signalFormula{$name});
  }
}


sub readMtdFile
{
  my ($fileName) = @_;

  open(FI, "<$fileName") or die "Could not open $fileName";
  my $fileSize = -s $fileName;
  my $fileData;
  read FI, $fileData, $fileSize;
  close FI;
  
  # fix one tag per line
  $fileData =~ s/></>\n</g;

  my $lineData;
  foreach $lineData (split(/\n/, $fileData))
  {
    if($lineData =~ /^\s*?<(\w+)(.*)>/)
    {
      my ($tag, $attributes) = ($1, $2);
      if($tag eq "signal")
      {
        my $signalName = ($attributes =~ / name=\"(.*?)\"/) ? $1 : "";
        my $signalNumber = ($attributes =~ / id=\"(.*?)\"/) ? $1 : "";
        $signalName{$signalNumber} = $signalName;
        #print "====> signal: $signalName - $signalNumber\n";
      }
    }
  }
}


# ------------- Read signals and structs from cache and vobs ----------------------------------------------------------


sub loadCache
{
  my ($cacheFile, $uniqueId) = @_;
  # The cache holds information about signals, structs and etc that is needed to do the decoding.
  
  my $cacheData = "";
  
  # <standalone replace cache start>
  if(!-e $cacheFile)
  {
    print STDERR "No cached data about signals and structs found.\n";
    return 0;
  }

  my $fileSize = -s $cacheFile;
  open(FI, "<$cacheFile") or die "Could not open cache";
  read FI, $cacheData, $fileSize;
  close FI;
  # <standalone replace cache end>

  # check that the cache is compatible with this version of the script
  $cacheData =~ s/(.*?)\n//;
  my $versionLine = $1;
  if($versionLine !~ /^Version: (\d+)/ || $1 < $SCRIPT_VERSION_NR)
  {
    print STDERR "Cached data needs to be updated due to updated decode script.\n";
    return 0;
  }

  $cacheData =~ s/(.*?)\n//;
  my $uniqueIdLine = $1;
  if($uniqueId ne "" && ($uniqueIdLine !~ /^UniqueId: (.+)/ || $1 ne $uniqueId))
  {
    print STDERR "Cached data needs to be updated due to other interface model files.\n";
    return 0;
  }
  
  my $hashName = "";
  foreach my $line (split(/\n/, $cacheData))
  {
    if($line =~ /^---(.*?)---/)
    {
      $hashName = $1;
    }
    elsif($line =~ /^(.*?)\|(.*)/)
    {
      if($hashName eq "structAttributes")
      {
        $structAttributes{$1} = $2;
      }
      elsif($hashName eq "typeDef")
      {
        $typeDef{$1} = $2;
      }
      elsif($hashName eq "prefixName")
      {
        $prefixName{$1} = $2;
      }
      elsif($hashName eq "signalStruct")
      {
        $signalStruct{$1} = $2;
      }
      elsif($hashName eq "signalName")
      {
        $signalName{$1} = $2;
      }
      elsif($hashName eq "enumValue")
      {
        $enumValue{$1} = $2;
      }
      elsif($hashName eq "isUnion")
      {
        $isUnion{$1} = $2;
      }
      elsif($hashName eq "rdrStruct")
      {
        $rdrStruct{$1} = $2;
      }
    }
  }

  return 1;
}


sub saveCache
{
  my ($cacheFile, $uniqueId) = @_;

  if(-e $cacheFile)
  {
    # remove old file first, it can be winked-in with no permission to overwrite it
    unlink $cacheFile;
  }
  
  open(FO, ">$cacheFile") or die "Could not save cache $cacheFile";
  print FO "Version: $SCRIPT_VERSION_NR\n";
  print FO "UniqueId: $uniqueId\n";
  saveHash("structAttributes", \%structAttributes);
  saveHash("typeDef", \%typeDef);
  saveHash("prefixName", \%prefixName);
  saveHash("signalStruct", \%signalStruct);
  saveHash("signalName", \%signalName);
  saveHash("enumValue", \%enumValue);
  saveHash("isUnion", \%isUnion);
  saveHash("rdrStruct", \%rdrStruct);
  close FO;
}


sub saveHash
{
  my ($name, $hashRef) = @_;
  my %hash = %{$hashRef};
  
  print FO "---$name---\n";
  
  my ($key, $value);
  while(($key, $value) = each %hash)
  {
    print FO "$key\|$value\n";
  }
}


sub updateCache
{
  my ($searchPaths, $filesRef) = @_;

  print STDERR "0% =================================================================== 100%\n";

  # create directory for temporary files and make sure no old files are saved there
  `mkdir -p $settings{tempstorage}`;
  unlink <$settings{tempstorage}/*.h>;
  unlink <$settings{tempstorage}/*.sig>;
  unlink <$settings{tempstorage}/*.c>;
  unlink <$settings{tempstorage}/*.cc>;

  # generate makefile for finding all interesting files
  my $decodeCommand = $settings{readcfiles} ? "$settings{scriptlocation} -cfiles" : $settings{scriptlocation};
  my $generatedFilePaths = "";
  my $directoryCompactNames = "";
  my $nrOfTargets = 0;

  my $makefileName = "$settings{tempstorage}/Makefile";
  open(FO, ">$makefileName") or die "Could not save $makefileName";
  my @searchPaths = split(/;/, $searchPaths);
  foreach my $searchPath (@searchPaths)
  {
    my $nrOfTargetsInCurrentPath = 0;
    foreach my $directory (split(/\n/, `ls -1 $searchPath`))
    {
      # do not try to find files in the lost+found directories
      if($directory =~ /lost\+found/) {next;}

      if(-d "$searchPath/$directory")
      {
        # this is a directory, add scan command for this directory to the makefile
        my $directoryCompactName = "$searchPath/$directory";
        $directoryCompactName =~ s/\///g;
        $directoryCompactNames .= "$directoryCompactName ";

        my $generatedFilePath = "$settings{tempstorage}/$directoryCompactName.zip";
        $generatedFilePaths .= "$generatedFilePath ";
        print FO "$generatedFilePath:\n\t$decodeCommand -scanforfiles $searchPath/$directory\n\n";
        $nrOfTargetsInCurrentPath++;
        $nrOfTargets++;
      }
    }
    
    if($nrOfTargetsInCurrentPath == 0)
    {
      # no targets were found in this search path, add the whole directory as a target in the makefile
      if(-d $searchPath)
      {
        my $directoryCompactName = $searchPath;
        $directoryCompactName =~ s/\///g;
        $directoryCompactNames .= "$directoryCompactName ";

        my $generatedFilePath = "$settings{tempstorage}/$directoryCompactName.zip";
        $generatedFilePaths .= "$generatedFilePath ";
        print FO "$generatedFilePath:\n\t$decodeCommand -scanforfiles $searchPath\n\n";
      }
    }
  }

  $decodeCommand .= " -debug" if $settings{debug};
  print FO "$settings{cachepath}: $generatedFilePaths\n\t$decodeCommand -buildcache $directoryCompactNames\n\n";
  print FO ".PHONY: all\nall: $settings{cachepath}\n";
  close FO;
  $nrOfTargets += 3;

  # execute makefile
  my $nrOfDots = 0;
  my $targetsFinished = 0;
  my $printOutput = $settings{debug};
  my $useUflag = $settings{force} ? " -u" : "";
  open(CMDIN, "clearmake$useUflag -v -J 10 -f $makefileName all|") or die "Could not execute clearmake";
  while(my $line = <CMDIN>)
  {
    print $line if $printOutput;

    if($line =~ /======================================/)
    {
      $targetsFinished++;
      
      my $oldNrOfDots = $nrOfDots;
      $nrOfDots = int($targetsFinished * 75 / $nrOfTargets);
      while($oldNrOfDots < $nrOfDots)
      {
        print STDERR ".";
        $oldNrOfDots++;
      }
    }
  }
  close CMDIN;

  while($nrOfDots < 75)
  {
    print STDERR ".";
    $nrOfDots++;
  }

  if(!loadCache($settings{cachepath}, ""))
  {
    print "Could not create cache\n";
    exit 1;
  }
}


sub findHeaderAndSignalFiles
{
  my ($searchPath) = @_;

  my %fileFound;
  my $filePaths = "";
  open(CMDIN, "find -L $searchPath 2>/dev/null|") or die "Could not run find";
  while(my $filePath = <CMDIN>)
  {
    chomp $filePath;

    # no cda, basic test, cda or deprecated files should be read
    if($filePath =~ /\/test\// || $filePath =~ /\/cda\// || $filePath =~ /\/cdaserver\// || $filePath =~ /OSE/ || $filePath =~ /deprecated/) {next;}

    if(($settings{readcfiles} && $filePath =~ /\.(?:sig|h|c|cc)$/) || $filePath =~ /\.(?:sig|h)$/)
    {
      $filePath =~ /(.*?)([^\/]+)$/;
      my ($fileDir, $fileName) = ($1, $2);

      if(-e $filePath && !defined $fileFound{$fileName})
      {
        $fileFound{$fileName} = 1;
        $filePaths .= "$filePath ";
      }
    }
  }
  close(CMDIN);

  my $searchCompactName = $searchPath;
  $searchCompactName =~ s/\///g;

  if($filePaths eq "")
  {
    print `touch $settings{tempstorage}/$searchCompactName.zip`;
  }
  else
  {
    unlink "$settings{tempstorage}/$searchCompactName.zip";
    print `zip -j $settings{tempstorage}/$searchCompactName.zip $filePaths`;
  }  
}


sub readHeaderAndSignalFiles
{
  my ($generatedFilePaths) = @_;
  
  foreach my $generatedFilePath (split(/ /, $generatedFilePaths))
  {
    my $zipFile = "$settings{tempstorage}/$generatedFilePath.zip";
    if(-s $zipFile > 0)
    {
      print `unzip -u -o $zipFile -d $settings{tempstorage}`;
    }
  }

  my @sigFiles;
  my $tmpFileName = "/tmp/$ENV{USER}_tmp.c";
  open(FO, ">$tmpFileName") or die "Could not save $tmpFileName";
  open(CMDIN, "ls -1 $settings{tempstorage}|") or die "Could not list files in $settings{tempstorage}";
  while(my $fileName = <CMDIN>)
  {
    chomp $fileName;
    if(($settings{readcfiles} && $fileName =~ /\.(?:sig|h|c|cc)$/) || $fileName =~ /\.(?:sig|h)$/)
    {
      print FO "\#include <$fileName>\n";
      print FO "\#undef __cm\n";
      print FO "\#undef CDA\n";
      print FO "\#undef LPP_CDA\n";
      print FO "\#undef __GNUC__\n";
    }

    if($fileName =~ /\.sig$/)
    {
      push @sigFiles, "$settings{tempstorage}\/$fileName";
    }
  } 
  print FO "int main(int argc, char *argv[]) {}\n";
  close FO;
  close CMDIN;

  # Read signal number and names for OSE signals from .sig files generated by RedEye
  foreach my $fileName (@sigFiles)
  {
    my $fileData = "";
    my $fileSize = -s $fileName;
    open(FI, "<$fileName") or die "Could not open cache";
    read FI, $fileData, $fileSize;
    close FI;
    
    while($fileData =~ s/\* Signal: (.*?) \((0x.*?)\)//)
    {
      my ($sigName, $sigNo) = ($1, hex $2);
      $signalName{$sigNo} = $sigName;
    }
  }

  my $cmd = "gcc -U __GNUC__ -U CDA -U LPP_CDA -D _FLEX_ASIC -w -E -I$settings{tempstorage} $tmpFileName 2>/dev/null";
  print "\n$cmd\n" if $settings{debug};

  my $counter = 0;
  my $fileData = "";
  open(CMDIN, "$cmd|") or die "Could not execute gcc";
  open(DBG, ">/vobs/erbs/ext/tools/flexTools/decode_gcc.c") if $settings{debug};
  while(my $line = <CMDIN>)
  {
    print DBG $line if $settings{debug};
    print STDERR "." if (($counter++ % 3000) == 0);
    next if($line =~ /^\#/);
    $fileData .= $line;
  }
  close DBG if $settings{debug};
  close CMDIN;

  # remove temporary file
  unlink $tmpFileName;
  
  # make sure all structs are formated the same way with one attribute per line
  $fileData =~ s/\}[\s\t]*$/}_0_/g;
  $fileData =~ s/\n/ /gs;
  $fileData =~ s/[\s\t]+\[/\[/g;
  $fileData =~ s/\{/\n{\n/gs;
  $fileData =~ s/,/,\n/gs;
  $fileData =~ s/;\s?/;\n/gs;
  $fileData =~ s/\}\_\0\_/}\n/gs;
  $fileData =~ s/\}/\n}/gs;
  
  my $structName = "";
  my $enumName = "";
  my $structAttributes = "";
  my $prefix = "";
  my $prefixStructAttributes = "";
  my $enumValue = 0;
  my $typeStructOrUnion = "";
  my @unknownEnumValues;

  foreach my $line (split(/\n/, $fileData))
  {
    # remove unnecessary white space in brackets
    while($line =~ s/\[(.*?)\s+(.*?)\]/\[$1$2\]/) {};

    if($line =~ /theMap\[(.*?)\] = \"(.*?)\"/)
    {
      # nc's map of handled ose signals with number and name, save signal
      my ($sigNo, $sigName) = ($1, $2);
      $sigNo =~ s/[LU\s]//g;
      if($sigNo !~ /_/)  # avoid unexpanded macros
      {
        my $sigNoEvaluated;
        $sigNoEvaluated = eval "$sigNo";
        $signalName{$sigNoEvaluated} = $sigName;
      }
    }
    elsif($structName eq "" && $line =~ /(?:typedef|)[\s\t]*((?:struct|union))[\s\t]+([a-zA-Z0-9_]+[SU]?)[\s\t]+$/)
    {
      my ($newType, $newStructName) = ($1, $2);
      
      # make sure that the struct is not already saved
      if(!defined $structAttributes{$newStructName})
      {
        $structName = $newStructName;
        $typeStructOrUnion = $newType;
      }
      $enumName = "";
    }
    elsif($structName eq "" && $line =~ /(?:typedef|)[\s\t]*((?:struct|union))[\s\t]+$/)
    {
      $typeStructOrUnion = $1;
      $structName = "unknown";
      $enumName = "";
    }
    elsif($line =~/typedef[\s\t]+enum[\s\t]+([a-zA-Z0-9_]+)/)
    {
      $enumName = $1;
      $typeDef{$enumName} = "enum";
      $enumValue = 0;
    }
    elsif($line =~/typedef[\s\t]+enum/)
    {
      $enumName = "unknown";
      @unknownEnumValues = ();
      $enumValue = 0;
    }
    elsif($line =~/typedef[\s\t]+(.*)[\s\t]+([^\s\t]+?);/)
    {
      $typeDef{$2} = $1;
    }
    elsif($enumName ne "")
    {
      # currently reading an enum
      if($line =~ /^[\s\t]*\}[\s\t]*([a-zA-Z0-9_]+);/)
      {
        my $newEnumName = $1;
        if($newEnumName ne $enumName)
        {
          $typeDef{$newEnumName} = "enum";
          foreach my $enumValue (@unknownEnumValues)
          {
            $enumValue{$newEnumName, $enumValue} = $enumValue{$enumName, $enumValue};
            delete $enumValue{$enumName, $enumValue};
          }
        }
        $enumName = "";
      }
      elsif($line =~ /^[\s\t]*\}/)
      {
        $enumName = "";
      }
      elsif($line =~ /[\s\t]+(\w+)[\s\t]*=[\s\t]*(\d+)/)
      {
        my $enumVariabelName = $1;
        $enumValue = $2;
        $enumValue{$enumName, $enumValue} = $enumVariabelName;
        if($enumName eq "unknown") {push @unknownEnumValues, $enumValue;}
        $enumValue++;
      }
      elsif($line =~ /[\s\t]*(\w+)/)
      {
        my $enumVariabelName = $1;
        $enumValue{$enumName, $enumValue} = $enumVariabelName;
        if($enumName eq "unknown") {push @unknownEnumValues, $enumValue;}
        $enumValue++;
      }
    }
    elsif($structName ne "")
    {
      # currently reading a struct
      if($prefix ne "" && $line =~ /^[\s\t]*\}[\s\t]*([a-zA-Z0-9_]+)(\[[0-9x]+\])?[\s\t]*?;/)
      {
        my ($name, $nrOf) = ($1, $2);
        $prefixName{$prefix} = $name;
        my $prefixStructName = "$structName.$name";
        $structAttributes{$prefixStructName} = $prefixStructAttributes;
        if($nrOf ne "")
        {
          $nrOf =~ s/^\[(.*)\]$/$1/;
          $nrOf = hex($nrOf) if $nrOf =~ /x/;
          $name .= "\[$nrOf\]";
        }
        $structAttributes .= "$prefixStructName=\.$name,";

        $prefix = "";
        $prefixStructAttributes = "";
      }
      elsif($line =~ /^[\s\t]*\}[\s\t]*([a-zA-Z0-9_]+[SU]?);/)
      {
        $structName = $1;
        $structAttributes{$structName} = $structAttributes;
        if($typeStructOrUnion eq "union")
        {
          $isUnion{$structName} = 1;
        }
        else
        {
          delete $isUnion{$structName};
        }

        $structAttributes = "";
        $structName = "";
        $prefix = "";
      }
      elsif($line =~ /^[\s\t]*\}/)
      {
        $structAttributes{$structName} = $structAttributes;
        if($typeStructOrUnion eq "union")
        {
          $isUnion{$structName} = 1;
        }
        else
        {
          delete $isUnion{$structName};
        }

        $structAttributes = "";
        $structName = "";
        $prefix = "";
      }
      elsif($line =~ /^[\s\t]+((?:union|struct))[\s\t]*\{?[\s\t]*$/)
      {
        my ($prefixType) = ($1);
        $prefixNr++;
        $prefix = "prefix$prefixNr";
        if($prefixType eq "union")
        {
          $isUnion{$prefix} = 1;
        }
        else
        {
          delete $isUnion{$prefix};
        }
      }
      elsif($line =~ /^[\s\t]+((?:union|struct))[\s\t]*([a-zA-Z0-9_]+[SU]?)[^;]+$/)
      {
        my ($prefixType) = ($1);
        $prefixNr++;
        $prefix = "prefix$prefixNr";
        if($prefixType eq "union")
        {
          $isUnion{$prefix} = 1;
        }
        else
        {
          delete $isUnion{$prefix};
        }
      }
      elsif($line =~ /^[\s\t]+(.+?)[\s\t]+([a-zA-Z0-9_\[\]\*]+)[\s\t]*:[\s\t]*(\d+)[\s\t]*?;/)
      {
        my($type, $bitLength, $name) = ($1, $2, $3);
        if($name =~ s/\*//g)
        {
          $type .= "*";
        }
        $type =~ s/^CDA_PTR\(.*\)$/$1/;
        $type =~ s/^const (.*)$/$1/;
        if($prefix ne "")
        {
          $prefixStructAttributes .= "$type:$name=\.$bitLength,";
        }
        else
        {
          $structAttributes .= "$type:$name=\.$bitLength,";
        }
      }
      elsif($line =~ /^[\s\t]+(.+?)[\s\t]+([a-zA-Z0-9_\[\]\*\(\)]+)[\s\t]*?;/)
      {
        my($type, $name) = ($1, $2);
        if($name =~ s/\*//g)
        {
          $type .= "*";
        }
        $name =~ s/[\(\)]//g;
        $type =~ s/^CDA_PTR\((.*)\)$/$1/;
        $type =~ s/^const (.*)$/$1/;
        if($prefix ne "")
        {
          $prefixStructAttributes .= "$type=\.$name,";
        }
        else
        {
          $structAttributes .= "$type=\.$name,";
        }
      }
    }
    print STDERR "." if (($counter++ % 8000) == 0);
  }

  if($structName ne "")
  {
    $structAttributes{$structName} = $structAttributes;
  }

  # these types are handled by the script
  delete $typeDef{S16};
  delete $typeDef{S32};
  delete $typeDef{S64};
  delete $typeDef{U8};
  delete $typeDef{U16};
  delete $typeDef{U32};
  delete $typeDef{U64};
  delete $typeDef{CHAR};
}


sub readSignalNumbers
{
  # read LPP signals and signal numbers
  my $fileData = `cat $settings{signalfile}`;
  foreach my $fileLine (split(/\n/, $fileData))
  {
    if($fileLine =~ /^\#define (.*?) (\d+)U/)
    {
      my ($name, $number) = ($1, $2);
      if($name !~ /(?:MAX|MIN\d*)$/)   # ignore xx_MAX and xx_MIN
      {
        $signalName{$number} = $name;
      }
    }
  }
}


# ------------- Connect signals with structs --------------------------------------------------------------------------


sub guessSignalAndStructRelations
{
  # This function is used to guess which struct each signal is using. Normally they are named something similary like
  # the signal UP_DLRLCPE_EI_DL_SI_DATA_IND which uses the struct DLRLCPE_dlSiDataIndS. The function will match parts
  # of the signal and struct names and find the struct that best matches the signal name

  my $nrOfParallelThreads = 20;

  # create list of all signals where the struct is unknown
  my @signalNames;
  foreach my $signalName (values %signalName)
  {
    if(!defined $signalStruct{$signalName})
    {
      # if this signal is a LPP signal, check it there is a non-lpp signal with a defined struct, if so copy the struct
      if($signalName =~ /LPP_(.+)/)
      {
        my $restOfSignal = $1;
        if(defined $signalStruct{$restOfSignal})
        {
          $signalStruct{$signalName} = $signalStruct{$restOfSignal};
        }
      }
      
      if(!defined $signalStruct{$signalName}) {push @signalNames, $signalName;}
    }
  }

  my $nrOfSignalNamesPerThread = int (($#signalNames + 1) / $nrOfParallelThreads) + 1;
  my $counter = 0;
  my @children;
  my @outputFiles;

  foreach my $childNr (1..$nrOfParallelThreads)
  {
    # create list of signal names to process for this thread
    my @signalNamesToProcess;
    if($childNr == $nrOfParallelThreads)
    {
      push @signalNamesToProcess, @signalNames;
    }
    else
    {
      foreach my $i (1..$nrOfSignalNamesPerThread)
      {
        my $signalName;
        if(defined($signalName = shift @signalNames))
        {
          push @signalNamesToProcess, $signalName;
        }
      }
    }

    $counter += 2;
    my $outputFilePath = "/tmp/tmp_$ENV{USER}_$childNr.result";
    my $pid;

    if(!defined($pid = fork()))
    {
      print STDERR "Error: Could not fork new process for parallel execution. Exiting.\n";
      exit 1;
    }
    elsif($pid)
    {
      # parent
      push @children, $pid;
      push @outputFiles, $outputFilePath;
    }
    else
    {
      # child
      open(FO, ">$outputFilePath") or die "Could not save temporary file $outputFilePath";
      foreach my $signalName (@signalNamesToProcess)
      {
        my $modifiedSignalName = $signalName;
        $modifiedSignalName =~ s/\_//g;

        my $bestMatchStructName = "";
        my $bestMatchMatches = -100;

        foreach my $structName (keys %structAttributes)
        {
          if(length($structName) < 8) {next;}

          my $modifiedStructName = $structName;
          $modifiedStructName =~ s/\_//g;

          my $matches = 0;
          my $nonMatches = 0;
          my $l = length($modifiedStructName) - 5;
          foreach my $i (0..$l)
          {
            my $part = substr $modifiedStructName, $i, 5;
            if($modifiedSignalName =~ /$part/i)
            {
              $matches++;
            }
            else
            {
              $nonMatches++;
            }
          }

          # check if best match
          if(($matches >= length($modifiedStructName) / 3) && (($matches-$nonMatches) > $bestMatchMatches))
          {
            # make sure the signal type matches the struct type, to avoid basic misstakes
            if($modifiedSignalName =~ /((?:IND|REQ|REJ|CFM))$/i)
            {
              my $signalType = $1;
              if($modifiedStructName =~ /${signalType}S?$/i)
              {
                $bestMatchMatches = ($matches-$nonMatches);
                $bestMatchStructName = $structName;
              }
            }
            else
            {
              $bestMatchMatches = ($matches-$nonMatches);
              $bestMatchStructName = $structName;
            }
          }
        }

        if($bestMatchStructName ne "")
        {
          print FO "$signalName\t$bestMatchStructName\n";
        }
        print STDERR "." if (($counter++ % 20) == 0);
      }
      close FO;
      exit 0;
    }
  }

  # wait for all children to finish
  my $finalStatus = 0;
  foreach my $childPid (@children)
  {
    waitpid($childPid, 0);
    my $status = $?;
    if($status != 0)
    {
      $finalStatus = $status;
    }
  }
  
  if($finalStatus != 0)
  {
    print STDERR "Error: One child exited with status $finalStatus. Exiting.\n";
    exit 1;
  }
  
  foreach my $outputFile (@outputFiles)
  {
    open(FI, "<$outputFile") or die "Could not open temporary file $outputFile";
    while(my $line = <FI>)
    {
      if($line =~ /(.*)\t(.*)\n/)
      {
        $signalStruct{$1} = $2;  # 1: signalName, 2: structName
      }
    }
    close FI;
    unlink $outputFile;
  }
}


# ------------- Decode interactive ------------------------------------------------------------------------------------


sub decodeInteractive
{
  $FO = *STDOUT;

  my $structName = $settings{struct};
  if($structName eq "")
  {
    print "(To decode MAC PDU, RLC PDU, PDCP PDU, GTP-U or IP, enter either 'dlmacpdu', 'ulmacpdu', 'rlcdrbpdu', 'rlcsrbpdu', 'pdcpdrbpdu', 'pdcpsrbpdu', 'gtpu', 'sctp' or 'ip')\n\n";
    print "Enter struct to use: ";
    $structName = <STDIN>;
    chomp $structName;
  }
  
  if(!isPdu($structName))
  {
    if(!defined $structAttributes{$structName})
    {
      if(defined $signalStruct{$structName})
      {
        $structName = $signalStruct{$structName};
      }

      if(!defined $structAttributes{$structName})
      {
        print "Struct unknown: $structName\n";
        exit 1;
      }
    }
  }
  
  print "Enter data to decode in hex format (finish with ctrl + d): ";
  $signalData = "";
  while(my $line = <STDIN>)
  {
    chomp $line;
    if($line =~ /([0-9a-fA-Fx\s]+)$/)
    {
      my $newData = $1;
      $newData =~ s/0x//g;
      $newData =~ s/[\s\t]+//g;
      $signalData .= $newData;
    }
  }
  
  if(isPdu($structName))
  {
    print decodePdu($structName, "" , 0, "");
  }
  else
  {
    my $decodedData = "$structName {";
    if($settings{compactlevel} > 1) {$decodedData .= "\n"};
    $decodedData .= decodeStruct($structName, "", 1, "  ", 0);
    $decodedData .= "}\n";  
    print "$decodedData\n";
  }
}


# ------------- Decode files & stdin -----------------------------------------------------------------------------


sub decodeFiles
{
  if($settings{dct2000} ne "" || $settings{csv})
  {
    open($FO, ">/dev/null") or "Could not open stream to /dev/null";
  }

  foreach my $fileInputName (split(/ /, $settings{files}))
  {
    my $fileOutputName = $fileInputName;
    $fileOutputName =~ s/\.([^\.]*?)$/_decoded\.$1/;
    $fileOutputName .= "_decoded" unless $fileOutputName =~ /decoded/;
    if($settings{dct2000} eq "" && !$settings{csv} && -e $fileOutputName)
    {
      print STDERR "Error: Output file already exists: $fileOutputName. Skipping this file.\n";
    }
    elsif($fileInputName =~ /_decoded/)
    {
      print STDERR "Skipping already decoded file $fileInputName\n";
    }
    else
    {
      open($FI, "<$fileInputName") or die "Could not open $fileInputName";
      if($settings{dct2000} ne "" || $settings{csv})
      {
        decodeFile($fileInputName);
      }
      else
      {
        open($FO, ">$fileOutputName") or die "Could not open $fileOutputName";

        if($settings{text})
        {
          $FOTEXT = $FO;
        }
        elsif($settings{textonly})
        {
          $FOTEXT = $FO;
          open($FO, ">/dev/null") or "Could not open stream to /dev/null";
        }

        decodeFile($fileInputName);

        if($settings{textonly})
        {
          close $FOTEXT;
        }
        close $FO;

        print "Saved $fileOutputName\n";
      }

      close $FI;
    }
  }
}


sub decodeStdin
{
  $FI = *STDIN;
  
  if($settings{dct2000} ne "" || $settings{csv} || $settings{textonly})
  {
    open($FO, ">/dev/null") or "Could not open stream to /dev/null";
  }
  else
  {
    $FO = *STDOUT;
  }

  if($settings{text} || $settings{textonly})
  {
    $FOTEXT = *STDOUT;
  }

  decodeFile("");
}


sub getNextLine
{
  if($#inputDataLines > -1)
  {
    # if we have sorted data, read first line
    return shift @inputDataLines;
  }
  else
  {
    my $line = <$FI>;

    if($line =~/^ dsp\s+bfn\s+microSec/)
    {
      # the input might be ziplog_verbose, check cm pointers

      %cmMemoryPtrUsed = ();
      my $line2 = "";
      while($line2 ne "\n" && ($line2 = <$FI>))
      {
        if($line2 =~ /CM memory (.*?):/)   # special ziplog line with CM memory dumped in line
        {
          my ($cmMemoryPtr) = $1;
          $cmMemoryPtrUsed{$cmMemoryPtr}++;
        }
        push @inputDataLines, $line2;
      }
    }
    
    return $line;
  }
}


sub decodeFile
{
  my ($fileName) = @_;
  
  $signalData = "";
  $signalDataPlatform = "";
  $signalDataLength = "";
  $signalDataLengthToUse = 0;
  $signalTraceLine = "";
  $pduBitData = "";
  @inputDataLines = ();
  my $signalDataLines = "";
  my $signalName = "";
  my %moreDataExpected;
  my %savedSignalData;
  my %savedSignalDataLines;
  my $breakWhenBusTraceStarts = ($settings{compactlevel} == 0) ? "  " : "\n";

  # if struct has been specified on the command prompt, check that it exist
  if($settings{struct} ne "")
  {
    my $structName = $settings{struct};
    if(!isPdu($structName))
    {
      if(!defined $structAttributes{$structName})
      {
        print "Struct unknown: $structName\n";
        exit 1;
      }
    }
  }

  # read trace log from stdin and decode bus traces
  my $line;
  while($line = getNextLine())
  {
    chomp $line;

    if($line =~ /^\[.*?\].*(?:BUS|CONTINUATION).*?SigNo[\:=]\s?\(?([0-9a-fA-Fx]+)\)?\((\d+)\/(\d+)\)/)  # nc bus trace starts
    {
      my ($signalNumber, $partNr, $totalNrOfParts) = ($1, $2, $3);
      if($signalNumber =~ /^0x/) {$signalNumber = hex($signalNumber);}

      # if signal data has been read, decode it
      if($signalData ne "")
      {
        decodeData($signalName, $signalDataLines);
        $signalData = "";
        $signalDataLines = "";
        $signalDataPlatform = "";
      }

      $signalTraceLine = $line;
      $latestRadioTimeStamp = $latestBfn = $latestSfn = $latestSf = "";
      $signalName = "";
      if(defined $signalName{$signalNumber})
      {
        $signalName = $signalName{$signalNumber};
        $line =~ s/$signalNumber/$signalNumber = $signalName/;
        $signalDataPlatform = "cpp";

        if($partNr == $totalNrOfParts)
        {
          # copy over saved data
          $signalData = $savedSignalData{$signalName};
          $signalDataLines = $savedSignalDataLines{$signalName};
          delete $moreDataExpected{$signalName};
        }
        elsif($partNr == 1)
        {
          delete $savedSignalData{$signalName};
          delete $savedSignalDataLines{$signalName};
          $moreDataExpected{$signalName} = 1;
        }
      }
      else
      {
        $line =~ s/$signalNumber/$signalNumber = unknown signal/;
      }

      print $FO "$line$breakWhenBusTraceStarts";
    }
    elsif($line =~ /^\[.*?\].*BUS.*?:SigNo: (\d+)/)  # nc bus trace starts
    {
      my ($signalNumber) = ($1);

      # if signal data has been read, decode it
      if($signalData ne "")
      {
        decodeData($signalName, $signalDataLines);
        $signalData = "";
        $signalDataLines = "";
        $signalDataPlatform = "";
      }

      $signalTraceLine = $line;
      $latestRadioTimeStamp = $latestBfn = $latestSfn = $latestSf = "";
      $signalName = "";
      if(defined $signalName{$signalNumber})
      {
        $signalName = $signalName{$signalNumber};
        $line =~ s/$signalNumber/$signalNumber = $signalName/;
        $signalDataPlatform = "cpp";
      }
      else
      {
        $line =~ s/$signalNumber/$signalNumber = unknown signal/;
      }

      print $FO "$line$breakWhenBusTraceStarts";
    }
    elsif($line =~ /^\[.*?\].*(?:BUS|CONTINUATION).* ([^\s]+?)\(([0-9a-fA-Fx]+)\) .*\((\d+)\/(\d+)\)/)  # bbmc bus trace starts - new style
    {
      my ($newSignalName, $signalNumber, $partNr, $totalNrOfParts) = ($1, $2, int $3, int $4);
      if($signalNumber =~ /^0x/) {$signalNumber = hex($signalNumber);}

      # if signal data has been read, decode it
      if($signalData ne "")
      {
        decodeData($signalName, $signalDataLines);
        $signalData = "";
        $signalDataLines = "";
        $signalDataPlatform = "";
      }

      $signalTraceLine = $line;
      $latestRadioTimeStamp = $latestBfn = $latestSfn = $latestSf = "";
      $signalName = $newSignalName;
      if(defined $signalName{$signalNumber})
      {
        $signalName = $signalName{$signalNumber};
        $line =~ s/$signalNumber/$signalNumber = $signalName/;
        $signalDataPlatform = "cpp";

        if($newSignalName ne $signalName)
        {
          print $FO "Decoder warning: Below signal name does not match the signal number. Make sure you run both TET.pl and decode in a correct clearcase view, use -u flag to update the decoder cache.\n";
        }

        if($partNr == $totalNrOfParts)
        {
          # copy over saved data
          $signalData = $savedSignalData{$signalName};
          $signalDataLines = $savedSignalDataLines{$signalName};
          delete $moreDataExpected{$signalName};
        }
        elsif($partNr == 1)
        {
          delete $savedSignalData{$signalName};
          delete $savedSignalDataLines{$signalName};
          $moreDataExpected{$signalName} = 1;
        }
      }
      else
      {
        $line =~ s/$signalNumber/$signalNumber = unknown signal/;
      }

      print $FO "$line$breakWhenBusTraceStarts";
    }
    elsif($line =~ /^\[.*?\].*(?:BUS|CONTINUATION).* ([^\s]+?)\(([0-9a-fA-Fx]+)\) /)  # bbmc bus trace starts - new style
    {
      my ($newSignalName, $signalNumber) = ($1, $2);
      if($signalNumber =~ /^0x/) {$signalNumber = hex($signalNumber);}

      # if signal data has been read, decode it
      if($signalData ne "")
      {
        decodeData($signalName, $signalDataLines);
        $signalData = "";
        $signalDataLines = "";
        $signalDataPlatform = "";
      }

      $signalTraceLine = $line;
      $latestRadioTimeStamp = $latestBfn = $latestSfn = $latestSf = "";
      $signalName = $newSignalName;
      if(defined $signalName{$signalNumber})
      {
        $line =~ s/$signalNumber/$signalNumber = $signalName/;
        $signalDataPlatform = "cpp";

        if($signalName ne $signalName{$signalNumber})
        {
          print $FO "Decoder warning: Below signal name does not match the signal number. Make sure you run both TET.pl and decode in a correct clearcase view, use -u flag to update the decoder cache.\n";
        }
      }
      else
      {
        $line =~ s/$signalNumber/$signalNumber = unknown signal/;
      }

      print $FO "$line$breakWhenBusTraceStarts";
    }
    elsif($line =~ /^\[.*?\].*BUS.*?:SigNo\((.*?)\)/)   # bbmc bus traces starts
    {
      my ($signalNumberHex) = ($1);
      my $signalNumber = hex($signalNumberHex);

      # if signal data has been read, decode it
      if($signalData ne "")
      {
        decodeData($signalName, $signalDataLines);
        $signalData = "";
        $signalDataLines = "";
        $signalDataPlatform = "";
      }

      $signalTraceLine = $line;
      $latestRadioTimeStamp = $latestBfn = $latestSfn = $latestSf = "";
      $signalName = "";
      if(defined $signalName{$signalNumber})
      {
        $signalName = $signalName{$signalNumber};
        $line =~ s/$signalNumberHex/$signalNumberHex = $signalName/;
        $signalDataPlatform = "cpp";
      }
      else
      {
        $line =~ s/$signalNumberHex/$signalNumberHex = unknown signal/;
      }

      print $FO "$line$breakWhenBusTraceStarts";
    }
    elsif($line =~ /^.*BUS.*?([^\s]+?)\(([0-9a-fA-Fx]+)\)/)   # bbmc basic test bus trace starts
    {
      my ($newSignalName, $signalNumber) = ($1, $2);
      if($signalNumber =~ /^0x/) {$signalNumber = hex($signalNumber);}

      # if signal data has been read, decode it
      if($signalData ne "")
      {
        decodeData($signalName, $signalDataLines);
        $signalData = "";
        $signalDataLines = "";
        $signalDataPlatform = "";
      }

      $signalTraceLine = $line;
      $latestRadioTimeStamp = $latestBfn = $latestSfn = $latestSf = "";
      $signalName = $newSignalName;
      if(defined $signalName{$signalNumber})
      {
        $line =~ s/$signalNumber/$signalNumber = $signalName/;
        $signalDataPlatform = "cpp";

        if($signalName ne $signalName{$signalNumber})
        {
          print $FO "Decoder warning: Below signal name does not match the signal number. Make sure you run both TET.pl and decode in a correct clearcase view, use -u flag to update the decoder cache.\n";
        }
      }
      else
      {
        $line =~ s/$signalNumber/$signalNumber = unknown signal/;
      }

      print $FO "$line$breakWhenBusTraceStarts";
    }
    elsif($line =~ /^\[?[\dx]{4}-.*?\]? (.*?PDU) (?:REC|SEND)(.*)/ ||  # bb pdu trace starts, new format
          $line =~ /^\[?[\dx]{4}-.*?\]? (.*?PDU) (?:\-\:0 |)(?:BIN|BUS|bin|bus)(.*)/)    # old format
    {
      my ($radioTimeAndTraceObject, $restOfLine) = ($1, $2);

      # if signal data has been read, decode it
      if($signalData ne "")
      {
        decodeData($signalName, $signalDataLines);
        $signalData = "";
        $signalDataLines = "";
        $signalDataPlatform = "";
      }

      $signalTraceLine = $line;
      $latestRadioTimeStamp = $latestBfn = $latestSfn = $latestSf = "";
      if($restOfLine =~ /pduSizeInBytes=(\d+)/i || $restOfLine =~ /Length[=:](\d+)/i || $restOfLine =~ /size (\d+)/i)
      {
        $signalDataLengthToUse = $1;
      }
            
      if($radioTimeAndTraceObject =~ /rlc/i)
      {
        if($radioTimeAndTraceObject =~ /srb/i)
        {
          $signalName = "rlcsrbpdu";
        }
        else
        {
          $signalName = "rlcdrbpdu";
        }
      }
      elsif($radioTimeAndTraceObject =~ /pdcp/i)
      {
        if($radioTimeAndTraceObject =~ /srb/i)
        {
          $signalName = "pdcpsrbpdu";
        }
        else
        {
          $signalName = "pdcpdrbpdu";
        }
      }
      elsif($radioTimeAndTraceObject =~ /dlmac/i)
      {
        $signalName = "dlmacpdu";
      }
      elsif($radioTimeAndTraceObject =~ /ulmac/i)
      {
        $signalName = "ulmacpdu";
      }

      if($radioTimeAndTraceObject =~ /(0x[0-9a-fA-F]+)/)
      {
        $latestRadioTimeStamp = $1;
        if($settings{decoderadiotime})
        {
          my $decodedRadioTime = decodeRadioTime($latestRadioTimeStamp);
          $line =~ s/$latestRadioTimeStamp/$latestRadioTimeStamp=($decodedRadioTime)/;
        }
      }

      print $FO "$line$breakWhenBusTraceStarts";
    }

    elsif($line =~ /^\[?[\dx]{4}-.*?\]? (.*?RohcFt_(?:comp|ific)) (?:REC|BIN_SEND)(.*)/)  # rohc trace starts
    {
      my ($radioTimeAndTraceObject, $restOfLine) = ($1, $2);
      
      # if signal data has been read, decode it
      if($signalData ne "")
      {
        decodeData($signalName, $signalDataLines);
        $signalData = "";
        $signalDataLines = "";
        $signalDataPlatform = "";
      }

      $signalTraceLine = $line;
      $latestRadioTimeStamp = $latestBfn = $latestSfn = $latestSf = "";
      if($restOfLine =~ /pduSizeInBytes=(\d+)/i)
      {
        $signalDataLengthToUse = $1;
      }
      if($restOfLine =~ /payloadLengthBytes=(\d+)/i)
      {
        $signalDataLengthToUse = $1;
      }
      
      $signalName = "rohc";

      if($restOfLine =~ /RoHC feedback sent/i)
      {
        $signalName = "rohcfb";
      }
      
      if($radioTimeAndTraceObject =~ /(0x[0-9a-fA-F]+)/)
      {
        $latestRadioTimeStamp = $1;
        if($settings{decoderadiotime})
        {
          my $decodedRadioTime = decodeRadioTime($latestRadioTimeStamp);
          $line =~ s/$latestRadioTimeStamp/$latestRadioTimeStamp=($decodedRadioTime)/;
        }
      }
      
      print $FO "$line$breakWhenBusTraceStarts";
    }
    elsif($line =~ /^\[?[\dx]{4}-.*?\]? (.*?_Igtpu) (?:\-\:0 |)(?:BIN|BUS|bin|bus)(.*)/)  # gtp-u trace starts
    {
      my ($radioTimeAndTraceObject, $restOfLine) = ($1, $2);

      # if signal data has been read, decode it
      if($signalData ne "")
      {
        decodeData($signalName, $signalDataLines);
        $signalData = "";
        $signalDataLines = "";
        $signalDataPlatform = "";
      }

      $signalTraceLine = $line;
      $latestRadioTimeStamp = $latestBfn = $latestSfn = $latestSf = "";
      if($restOfLine =~ /Length[=:](\d+)/i || $restOfLine =~ /size (\d+)/i)
      {
        $signalDataLengthToUse = $1;
      }
            
      $signalName = "gtpu";

      if($radioTimeAndTraceObject =~ /(0x[0-9a-fA-F]+)/)
      {
        $latestRadioTimeStamp = $1;
        if($settings{decoderadiotime})
        {
          my $decodedRadioTime = decodeRadioTime($latestRadioTimeStamp);
          $line =~ s/$latestRadioTimeStamp/$latestRadioTimeStamp=($decodedRadioTime)/;
        }
      }

      print $FO "$line$breakWhenBusTraceStarts";
    }
    elsif($line =~ /^\[?[\dx]{4}-.*?\]? .*?_Sctp.*? .*?(?:BIN|BUS|bin|bus)(.*)/)  # sctp trace starts
    {
      my ($restOfLine) = ($1);

      # if signal data has been read, decode it
      if($signalData ne "")
      {
        decodeData($signalName, $signalDataLines);
        $signalData = "";
        $signalDataLines = "";
        $signalDataPlatform = "";
      }

      $signalTraceLine = $line;
      $latestRadioTimeStamp = $latestBfn = $latestSfn = $latestSf = "";
      $signalName = "sctp";

      print $FO "$line$breakWhenBusTraceStarts";
    }
    elsif($line =~ /^\[?[\dx]{4}-.*?\]? (0x[0-9a-fA-F]+).*?(?:BIN|BUS|bin|bus).*?\s:\s(.*?)\s\((\d+)\)/)  # bb bus trace starts, this line must be after check for nc bus trace
    {
      my ($radioTime, $newSignalName, $newSignalNumber) = ($1, $2, $3);
      
      # if signal data has been read, decode it
      if($signalData ne "")
      {
        decodeData($signalName, $signalDataLines);
        $signalData = "";
        $signalDataLines = "";
        $signalDataPlatform = "";
      }

      $signalTraceLine = $line;
      $latestBfn = $latestSfn = $latestSf = "";
      $latestRadioTimeStamp = $radioTime;
      $signalName = $newSignalName;
      if($newSignalName ne $signalName{$newSignalNumber})
      {
        print $FO "Decoder warning: Below signal name does not match the signal number. Make sure you run both TET.pl and decode in a correct clearcase view, use -u flag to update the decoder cache.\n";
      }

      if($settings{decoderadiotime})
      {
        my $decodedRadioTime = decodeRadioTime($radioTime);
        $line =~ s/$radioTime/$radioTime=($decodedRadioTime)/;
      }

      print $FO "$line$breakWhenBusTraceStarts";
    }
    elsif($signalName ne "" &&
          $line =~ /^[\s\t]*[0-9a-fA-F]{4} ([0-9a-fA-F\s]+)/)  # signal data
    {
      my $newSignalData = $1;
      $newSignalData =~ s/[\s\t]+//g;

      if(defined $moreDataExpected{$signalName})
      {
        $savedSignalData{$signalName} .= $newSignalData;
        $savedSignalDataLines{$signalName} .= "$line\n";
      }
      else
      {
        $signalData .= $newSignalData;
        $signalDataLines .= "$line\n";
      }
    }
    elsif($signalName ne "" &&
          $line =~ /^[\s]*\[exec\]  ([0-9a-fA-F\s]+)/)  # signal data for bbmc basic test
    {
      my $newSignalData = $1;
      $newSignalData =~ s/[\s\t]+//g;

      if(defined $moreDataExpected{$signalName})
      {
        $savedSignalData{$signalName} .= $newSignalData;
        $savedSignalDataLines{$signalName} .= "$line\n";
      }
      else
      {
        $signalData .= $newSignalData;
        $signalDataLines .= "$line\n";
      }
    }
    elsif($signalName ne "" &&
          $line =~ /^\s([0-9a-fA-F\s]+)$/)  # signal data for bbmc basic test, new
    {
      my $newSignalData = $1;
      $newSignalData =~ s/[\s\t]+//g;

      if(defined $moreDataExpected{$signalName})
      {
        $savedSignalData{$signalName} .= $newSignalData;
        $savedSignalDataLines{$signalName} .= "$line\n";
      }
      else
      {
        $signalData .= $newSignalData;
        $signalDataLines .= "$line\n";
      }
    }
    elsif($line =~ /^\[?[\dx]{4}-.*?\]? (0x[0-9a-fA-F]+).*?rdr.*? trace from .*?rdr/i)  # rdr trace starts (target node)
    {
      my $radioTime = $1;
      
      # if signal data has been read, decode it
      if($signalData ne "")
      {
        decodeData($signalName, $signalDataLines);
        $signalData = "";
        $signalDataLines = "";
        $signalDataPlatform = "";
      }

      $signalTraceLine = $line;
      $latestBfn = $latestSfn = $latestSf = "";
      $latestRadioTimeStamp = $radioTime;
      $signalName = "rdr";

      if($settings{decoderadiotime})
      {
        my $decodedRadioTime = decodeRadioTime($radioTime);
        $line =~ s/$radioTime/$radioTime=($decodedRadioTime)/;
      }

      print $FO "$line$breakWhenBusTraceStarts";
    }
    elsif($line =~ /^\[?[\dx]{4}-.*?\]? (0x[0-9a-fA-F]+).*?rdr.*? .*$/i)  # rdr trace starts (basic test)
    {
      my $radioTime = $1;
      
      # if signal data has been read, decode it
      if($signalData ne "")
      {
        decodeData($signalName, $signalDataLines);
        $signalData = "";
        $signalDataLines = "";
        $signalDataPlatform = "";
      }

      $signalTraceLine = $line;
      $latestBfn = $latestSfn = $latestSf = "";
      $latestRadioTimeStamp = $radioTime;
      $signalName = "rdr_bt";

      if($settings{decoderadiotime})
      {
        my $decodedRadioTime = decodeRadioTime($radioTime);
        $line =~ s/$radioTime/$radioTime=($decodedRadioTime)/;
      }

      print $FO "$line$breakWhenBusTraceStarts";
    }
    elsif($line =~ /^\[.*?\]\[\s*?([0-9a-fA-F]+),.*?:LPP_.*? (?:<|&lt;)signo 0x([0-9a-fA-F]+).*?Reading (\d+) words from CM memory (.*?): (.*)/)   # special zip log line with CM memory dumped in line
    {
      # zip log receive and send,  example: [ 0][6e543e02,17654525]:LPP_receive:lnk: .*? <signo 0x13a,prio 0><0x4003001b 0x2d3aff08 0xffff001a 0xe6540095>
      my ($radioTime, $signalNumberHex, $newSignalDataLengthInWords, $cmMemoryPtr, $newSignalData) = ($1, $2, $3, $4, $5);

      $latestRadioTimeStamp = "0x$radioTime";
      my $decodedRadioTime = decodeRadioTime($latestRadioTimeStamp);
      $line =~ s/$radioTime/$radioTime=($decodedRadioTime)/;

      my $signalNumber = hex($signalNumberHex);
      $signalName = $signalName{$signalNumber};
      $line =~ s/signo 0x$signalNumberHex/signo 0x$signalNumberHex = $signalNumber = $signalName/gi;

      if(--$cmMemoryPtrUsed{$cmMemoryPtr} > 0)
      {
        $line =~ s/$newSignalData/This CM pointer was used in a later signal and the memory has therefore been overwritten/;
        print $FO "$line\n";
      }
      else
      {
        delete $cmMemoryPtrUsed{$cmMemoryPtr};
        print $FO "$line\n";
        $newSignalData =~ s/[\s\t]+//g;
        $signalData = $newSignalData;

        # if signal data has been read, decode it
        if($signalData ne "")
        {
          if($signalData =~ /^(.{8})/)
          {
            my $signalNumberInSignalData = hex($1);
            if($signalNumber != $signalNumberInSignalData)
            {
              print $FO "Warning! Signal number in zip log ($signalNumber) does not match first attribute in CM memory ($signalNumberInSignalData) which usually is sigNo. Data might be incorrect (overwritten).\n";
            }
          }

          decodeData($signalName, "");
          $signalData = "";
          $signalName = "";
        }
      }
    }
    elsif($line =~ /^\[.*?\]\[\s*?([0-9a-fA-F]+),.*?jobno 0x[0-9a-fA-F]+,/)  # zip log jobs
    {
      my ($radioTime) = ($1);
      $latestRadioTimeStamp = "0x$radioTime";
      my $decodedRadioTime = decodeRadioTime($latestRadioTimeStamp);
      $line =~ s/$radioTime/$radioTime=($decodedRadioTime)/;
      $line =~ s/signo 0x([0-9a-fA-F]+)/signo 0x$1 = $signalName{hex($1)}/gi;
      $line =~ s/jobno 0x([0-9a-fA-F]+)/jobno 0x$1 = $stridName{$stridThreadsInGroup, hex($1)}/gi;
      print $FO "$line\n";
    }
    elsif($line =~ /^\[.*?\]\[\s*?([0-9a-fA-F]+),/)  # zip log other
    {
      my ($radioTime) = ($1);
      $latestRadioTimeStamp = "0x$radioTime";
      my $decodedRadioTime = decodeRadioTime($latestRadioTimeStamp);
      $line =~ s/$radioTime/$radioTime=($decodedRadioTime)/;
      $line =~ s/signo 0x([0-9a-fA-F]+)/signo 0x$1 = $signalName{hex($1)}/gi;
      print $FO "$line\n";
    }
    elsif($line =~ /^(\d+): \(group: (\d+)\) (.+)/)  # strid table with names
    {
      my ($id, $groupNumber, $name) = ($1, $2, $3);
      $stridName{$groupNumber, $id} = $name;
      if($name =~ /Thread$/)
      {
        # find out which group that contains threads by checking the names, at least some are named something with thread
        $stridThreadsInGroup = $groupNumber;
      }
      print $FO "$line\n";
    }
    elsif($line =~ /^buff_p: .*?, beginMark: .*?, bfn: ([0-9a-fA-Fx]+), pid: 0x108, sigNo: 0x([0-9a-fA-F]+)/)
    {
      my ($radioTime, $sigNo) = ($1, $2);
      my $decodedRadioTime = decodeRadioTime($radioTime);
      $line =~ s/bfn: $radioTime/bfn: $radioTime=($decodedRadioTime)/i;
      if($sigNo > 0)
      {
        $line =~ s/sigNo: 0x([0-9a-fA-F]+)/sigNo: 0x$1 = $signalName{hex($1)}/i;
      }
      print $FO "$line\n";
    } 
    elsif($line =~ /^[0-9a-fA-F\s]{8}\s{4}([0-9a-fA-F\s]+)/)  # readcm output
    {
      my $newSignalData = $1;
      $newSignalData =~ s/[\s\t]+//g;

      $signalData .= $newSignalData;
      $signalDataLines .= "$line\n";

      print $FO "$line\n";
    }
    elsif($line =~ /^readcm end:/)
    {
      print $FO "$line\n\n";

      my $structName = $settings{struct};
      my $decodedData = "$structName {";
      if($settings{compactlevel} > 1) {$decodedData .= "\n"};
      $decodedData .= decodeStruct($structName, "", 1, "  ", 0);
      $decodedData .= "}\n";
      print $FO "$decodedData\n";

      $signalData = "";
      $signalDataLines = "";
      $signalName = "";
      $signalDataPlatform = "";
    }
    else  # any other trace
    {
      # if signal data has been read, decode it
      if($signalData ne "")
      {
        decodeData($signalName, $signalDataLines);
        $signalData = "";
        $signalDataLines = "";
        $signalName = "";
        $signalDataPlatform = "";
      }

      if($line =~ /^\[?[\dx]{4}-.*?\] (0x[0-9a-fA-F]+)/)
      {
        $latestRadioTimeStamp = $1;
        if($settings{decoderadiotime})
        {
          my $decodedRadioTime = decodeRadioTime($latestRadioTimeStamp);
          $line =~ s/$latestRadioTimeStamp/$latestRadioTimeStamp=($decodedRadioTime)/;
        }
      }

      print $FO "$line\n";
    }
  }

  if($signalData ne "")
  {
    decodeData($signalName, $signalDataLines);
  }

  # save signal data to .csv files if that flag has been set
  if($settings{csv})
  {
    saveCsvFiles($fileName);
  }
}


sub saveCsvFiles
{
  my ($fileName) = @_;
  
  # if decoding stdin a directory name must be generated, otherwise reuse log file name
  if($fileName eq "")
  {
    my $dateTime = `date '+%Y-%m-%d_%H:%M'`;
    chomp $dateTime;
    $fileName = "stdin_$dateTime";
  }

  # create a directory where these files will be located
  my $csvPath = "${fileName}_csv";
  `mkdir -p $csvPath`;
  
  # save csv files
  foreach my $structName (keys %savedStructData)
  {
    my $csvFileName = "$csvPath/$structName.csv";
    open(FO_CSV, ">$csvFileName") or die "Could not save $csvFileName";

    my @attributeNames = split(/,/, $savedStructStructure{$structName});
    my $first = 1;
    foreach my $attributeName (@attributeNames)
    {
      print FO_CSV ";" unless $first; $first = 0;
      print FO_CSV "$attributeName";
    }
    print FO_CSV "\n";

    foreach my $signalHashRef (@{$savedStructData{$structName}})
    {
      $first = 1;
      foreach my $attributeName (@attributeNames)
      {
        print FO_CSV ";" unless $first; $first = 0;
        print FO_CSV "$signalHashRef->{$attributeName}";
      }
      print FO_CSV "\n";
    }
    
    close FO_CSV;
  }

  print "csv files saved in $csvPath/\n";
}


sub decodeRadioTime
{
  my ($radioTime) = @_;
  
  if($radioTime =~ /0x(.+)(..)(..)(.)$/)
  {
    my ($bfnCoded, $hfnCoded, $bfCoded, $countCoded) = ($1, $2, $3, $4);
    $latestBfn = hex($bfnCoded);
    $latestSfn = $latestBfn & 0b001111111111;
    my $hfn = hex($hfnCoded);
    $latestSf = sprintf("%.2f", $hfn / 15);
    my $bf = hex($bfCoded);
    my $count = hex($countCoded);
    return "bfn:$latestBfn, sfn:$latestSfn, sf:$latestSf, bf:$bf";
  }
  
  return "";
}


sub decodeRadioTimeToSeconds
{
  my ($radioTime) = @_;
  
  if($radioTime =~ /0x(.+)(.....)$/)
  {
    my ($bfnCoded, $subBfnCoded) = ($1, $2);
    my $bfn = hex($bfnCoded);
    my $subBfn = hex($subBfnCoded);
    my $timeCycles = ($bfn * 614400) + $subBfn;
    my $timeMs = $timeCycles / 61440;
    my $timeS = sprintf("%.4f", $timeMs / 1000);
    return $timeS;
  }
  
  return "0.0";
}


# ------------- Decode data ------------------------------------------------------------------------------------


sub decodeData
{
  my ($signalName, $signalDataLines) = @_;

  if($signalDataLengthToUse > 0)
  {
    $signalData = substr $signalData, 0, ($signalDataLengthToUse * 2);
  }
  
  if($signalName eq "rdr_bt")
  {
    # RDR traces from basic test has some padding in the beginning, remove it
    $signalData = substr $signalData, 4;
    $signalName = "rdr";
  }
  
  if($signalName eq "rdr")
  {
    my $rdrFragmentNumber = hex(substr $signalData, 0, 4);
    my $rdrNumber = hex(substr $signalData, 4, 4);
    my $rdrStruct = $rdrStruct{$rdrNumber, $rdrFragmentNumber};
    if(defined $rdrStruct)
    {
      decodeSignal($signalName, $signalDataLines, $rdrStruct);
    }
    else
    {
      # unknown signal, show encoded hex data
      print $FO $signalDataLines;
      print $FO "(Unknown RDR measurement $rdrNumber)\n";
    }
  }
  elsif(isPdu($signalName))
  {
    decodePdu($signalName, $signalDataLines, 0, "");
  }
  else
  {
    decodeSignal($signalName, $signalDataLines, "");
  }

  $signalDataLengthToUse = 0;
}


# ------------- Decode signal ------------------------------------------------------------------------------------


sub decodeSignal
{
  my ($signalName, $signalDataLines, $signalStructName) = @_;
  
  %savedAttributeValue = ();
  %savedAttributeValueFullPath = ();
  %savedDecodedAttributeFullPath = ();
  $decodedDataText = "";
  $signalDataEmptyWarningDisplayed = 0;
  %unionAttributeDisplayed = ();
  $currentStructStructure = "";

  if($signalStructName eq "") {$signalStructName = $signalStruct{$signalName}}
  if(defined $signalStructName)
  {
    # the signal has a known struct, decode signal data that is stored in the global variable $signalData
    my $intendentationDueToPosition = "";
    my $decodedData = "";
    if($settings{position})
    {
      $decodedData = "byte word $signalStructName {";
      $intendentationDueToPosition = "          ";
    }
    else
    {
      $decodedData = "$intendentationDueToPosition$signalStructName {";
    }
    if($settings{compactlevel} > 1) {$decodedData .= "\n"};
    $decodedData .= decodeStruct($signalStructName, "", 1, "  ", 0);
    $decodedData .= "$intendentationDueToPosition}\n";

    # check if any signal data hasn't been decoded
    if($signalData ne "")
    {
      my $rest = "";
      if($signalData =~ s/^(.{40})(.+)/$1/g)
      {
        $rest = "(+ ".((length($2)) / 2)." bytes more)";
      }
      $signalData =~ s/(..)/$1 /g;
      $decodedData .= "Decoder warning: Unused signal data found: $signalData$rest. Decoded data might be incorrect.\n";
    }

    if($decodedData =~ /decoder warning/i || $settings{showhexdata})
    {
      # show encoded hex data

      if($settings{compactlevel} == 0)
      {
        # remove returns
        $signalDataLines =~ s/\n/ /g;
      }

      print $FO $signalDataLines;
    }

    print $FO $decodedData;

    if($settings{text} || $settings{textonly})
    {
      my $traceTime = "";
      if($signalTraceLine =~ /^\[?([\dx]{4}-.*?\s.*?)\]? /)
      {
        $traceTime = $1;
      }
      
      print $FOTEXT "trace.time: $traceTime, trace.bfnregister: $latestRadioTimeStamp, trace.bfn: $latestBfn, trace.sfn: $latestSfn, trace.sf: $latestSf, signal.name: $signalName, signal.struct: $signalStructName, $decodedDataText\n";
    }
    elsif($settings{csv})
    {
      # add trace time details to saved struct structure and data
      if($settings{decoderadiotime})
      {
        $currentStructStructure = "trace.time,trace.bfnregister,trace.bfn,trace.sfn,trace.sf,$currentStructStructure";
        $savedDecodedAttributeFullPath{'trace.bfn'} = $latestBfn;
        $savedDecodedAttributeFullPath{'trace.sfn'} = $latestSfn;
        $savedDecodedAttributeFullPath{'trace.sf'} = $latestSf;
      }
      else
      {
        $currentStructStructure = "trace.time,trace.bfnregister,$currentStructStructure";
      }
      $savedDecodedAttributeFullPath{'trace.bfnregister'} = $latestRadioTimeStamp;
      if($signalTraceLine =~ /^\[?([\dx]{4}-.*?\s.*?)\]? /)
      {
        $savedDecodedAttributeFullPath{'trace.time'} = $1;
      }

      # check if the saved struct structure needs to be updated
      if(!defined $savedStructStructure{$signalStructName} || length $currentStructStructure > length $savedStructStructure{$signalStructName})
      {
        $savedStructStructure{$signalStructName} = $currentStructStructure;
      }
      
      # save data from this struct into a list
      if(!defined $savedStructData{$signalStructName})
      {
        my @list = ();
        $savedStructData{$signalStructName} = \@list;
      }
      my %element = %savedDecodedAttributeFullPath;
      push @{$savedStructData{$signalStructName}}, \%element;
    }
  }
  else
  {
    # unknown signal, show encoded hex data
    print $FO $signalDataLines;
    print $FO "(Unknown signal $signalName)\n";
  }
}


sub getTwoComplement
{
  my ($nrOfBits, $value) = @_;
  
  if($value >= (1 << ($nrOfBits - 1)))
  {
    return $value - (1 << $nrOfBits);
  }
  
  return $value;
}


# ------------- Decode struct ------------------------------------------------------------------------------------


sub decodeStruct
{
  my ($structName, $attributePath, $level, $intendentation, $insideUnion) = @_;

  my $decodedData = "";
  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  my $showPaddingAttributes = $settings{showpadding};

  if($level == 1)
  {
    $signalDataLength = length $signalData;
  }

  # check if signal is a union, copy signal data to reset for next attribute
  my $savedSignalData = $signalData;
  my $isUnion = 0;
  if($isUnion{$structName})
  {
    $isUnion = 1;
    $insideUnion = 1;
  }

  # count number of attributes
  my $totalNrOfAttributes = 0;
  foreach my $attributeDef (split(/,/, $structAttributes{$structName}))
  {
    $totalNrOfAttributes++;
  }
  
  my $lastAttributeName = "";
  my $lastAttributeValue = 0;
  my $attributeValue = 0;
  my $attributeValueAllBits = 0;
  my $bitLeft = 0;
  my $lastPrefixName = "";
  my $savedSignalData2 = "";
  my $signalDataAfterLargestUnion = "-";
  my $savedDecodedDataForUnion = "";
  my $savedDecodedDataTextForUnion = "";
  my %savedDecodedAttributeFullPathForUnion;
  my $unionAttributeAlreadyShown = 0;
  my $startLength = length $signalData;
  my $intendentationToData = "";
  my $spaces = "                                                                                                          ";

  # loop through all attributes and decode the data
  my $nrOfAttributes = 0;
  foreach my $attributeDef (split(/,/, $structAttributes{$structName}))
  {
    $nrOfAttributes++;
    
    if($isUnion)
    {
      # union => reset signal data for each attribute
      $signalData = $savedSignalData;
      $savedDecodedDataForUnion = $decodedData;
      $savedDecodedDataTextForUnion = $decodedDataText;
      %savedDecodedAttributeFullPathForUnion = %savedDecodedAttributeFullPath;
    }
    
    my $readBytes = ($startLength - length $signalData) / 2;

    # read information about the attribute
    $attributeDef =~ /(.*)=(.*)\.(.*)/;
    my ($attributeType, $prefixId, $attributeName) = ($1, $2, $3);
    
    if($attributeName =~ /\[(.*)\]/ && $1 ne int($1))
    {
      # array with size defined in constant which was not resolved when struct was read, try to resolve it now
      my $constantName = $1;
      while(defined $typeDef{$constantName} && $constantName ne $typeDef{$constantName})
      {
        $constantName = $typeDef{$constantName};
      }
      $attributeName =~ s/\[.*\]/\[$constantName\]/;
    }
    
    my $origAttributeType = $attributeType;
    $attributeType =~ s/^enum (.+)/$1/;
    my $prefixName = "";
    if($prefixId ne "")
    {
      $prefixName = $prefixName{$prefixId};
      $attributeName = "$prefixName.$attributeName";
      if($isUnion{$prefixId})
      {
        if($prefixName eq $lastPrefixName)
        {
          $signalData = $savedSignalData2;
        }
        else
        {
          $savedSignalData2 = $signalData;
        }
      }
    }
    $lastPrefixName = $prefixName;
    my $origAttributeName = $attributeName;

    # expand type def if used
    if($attributeType =~ /^(.*)\*$/)
    {
      $attributeType = $1;
      while(defined $typeDef{$attributeType} && $attributeType ne $typeDef{$attributeType})
      {
        $attributeType = $typeDef{$attributeType};
      }
      $attributeType .= "*";
    }
    else
    {
      while(defined $typeDef{$attributeType} && $attributeType ne $typeDef{$attributeType})
      {
        $attributeType = $typeDef{$attributeType};
      }
    }
    
    # for arrays, check how many elements that is allocated in the signal data (maxIndex) and how many
    # that should be displayed (maxDisplayIndex)
    my $maxIndex = 1;
    my $showIndex = 0;
    my $maxDisplayIndex = -1;
    my $attributeNameShort = $attributeName;
    $attributeNameShort =~ s/\[.*?\]//g;

    my $arraySizeVarHard = $arraySizeVariabelHard{"$structName, $attributeNameShort"};
    my $arraySizeVarSoft = $arraySizeVariabelSoft{"$structName, $attributeNameShort"};

    if(defined $arraySizeVarHard && defined $savedAttributeValue{$arraySizeVarHard})
    {
      # the attribute that holds the number of elements is hard coded
      $maxIndex = $savedAttributeValue{$arraySizeVarHard};
      $attributeName = $attributeNameShort;
      $origAttributeName = $attributeNameShort;
      $showIndex = 1;
    }
    elsif(defined $arraySizeVarSoft && defined $savedAttributeValue{$arraySizeVarSoft})
    {
      # the attribute that holds the number of elements is hard coded
      $maxIndex = $savedAttributeValue{$arraySizeVarSoft};
      if(($attributeName =~ /\[1\]/ && $maxIndex < 1) || ($attributeName =~ /\[[^\d]+\]/ && $maxIndex < 1))
      {
        # minimum one element is always expected
        $maxIndex = 1;
      }
      $attributeName = $attributeNameShort;
      $origAttributeName = $attributeNameShort;
      $showIndex = 1;
    }
    elsif($nrOfAttributes == $totalNrOfAttributes &&
          $lastAttributeName =~ /(?:nrof|noof|size|numberof|numof|length)/i &&
          $attributeName =~ s/\[1\]//)
    {
      # last attribute is an array and the second last attribute holds the size
      $maxIndex = (($lastAttributeValue > 0 || $signalData eq "") && !$insideUnion) ? $lastAttributeValue : 1;
      $maxDisplayIndex = $lastAttributeValue;
      $origAttributeName = $attributeNameShort;
      $showIndex = 1;
    }
    elsif($lastAttributeName =~ /(?:nrof|noof|size|numberof|numof|length)/i &&
          $attributeName =~ s/\[(\d+)U?\]//)
    {
      # last attribute is an array and the second last attribute holds the size
      $maxIndex = $1;
      $maxDisplayIndex = $lastAttributeValue;
      $origAttributeName = $attributeNameShort;
      $showIndex = 1;
    }
    elsif($attributeName =~ s/\[(.*?)\]\[(.*?)\]//)
    {
      # fix number of elements, array in array
      my ($array1, $array2) = ($1, $2);
      if($array1 =~ /(\d+)U?/)
      {
        $array1 = $1;
      }
      elsif(defined $enumValue{$array1})
      {
        $array1 = $enumValue{$array1};
      }
      else
      {
        $array1 = 1;
        $decodedData .= "Decoder warning: Size of next array unknown, rest of data is probably incorrect\n";
      }
      if($array2 =~ /(\d+)U?/)
      {
        $array2 = $1;
      }
      elsif(defined $enumValue{$array2})
      {
        $array2 = $enumValue{$array2};
      }
      else
      {
        $array2 = 1;
        $decodedData .= "Decoder warning: Size of next array unknown, rest of data is probably incorrect\n";
      }
      $maxIndex = $array1 * $array2;
      $origAttributeName = $attributeNameShort;
      $showIndex = 1;
    }
    elsif($attributeName =~ s/\[(.*?)\]//)
    {
      # fix number of elements
      $maxIndex = $1;
      if($maxIndex =~ /(\d+)U?/)
      {
        $maxIndex = $1;
      }
      elsif(defined $enumValue{$maxIndex})
      {
        $maxIndex = $enumValue{$maxIndex};
      }
      elsif(defined $savedAttributeValue{$maxIndex})
      {
        $maxIndex = $savedAttributeValue{$maxIndex};
      }
      else
      {
        $maxIndex = 1;
        $decodedData .= "Decoder warning: Size of next array unknown, rest of data is probably incorrect\n";
      }
      $origAttributeName = $attributeNameShort;
      $showIndex = 1;
    }
    
    # check if the attribute that holds the number of elements to display is hardcoded
    my $arrayDisplayVar = $arrayDisplayVariabel{"$structName, $origAttributeName"};
    if(!$settings{showallelements} &&
       defined $arrayDisplayVar &&
       defined $savedAttributeValue{$arrayDisplayVar})
    {
      $maxDisplayIndex = $savedAttributeValue{$arrayDisplayVar};
    }
    
    my $compressArray = 0;
    if($settings{compressarrays} && $attributeType =~ /^(?:U8|U16|U32|U64|S16|S32|S64|short|CHAR|char|int)$/)
    {
      # compress array if it is a list of numbers
      $compressArray = 1;
    }

    my $showType = "";
    if($settings{type})
    {
      # show attribute type for each attribute
      $showType = "$origAttributeType ";
    }
    
    if(defined $decodeAttributeAsPdu{$structName, $origAttributeName})
    {
      # for this attribute it has been defined that the rest of the signal should be decoded as a PDU
      if($compactOutput && $nrOfAttributes > 1) {$decodedData .= ", ";}
      $decodedData .= decodePdu($decodeAttributeAsPdu{$structName, $origAttributeName}, "", $level, $intendentation);
      $signalData = "";
      $maxIndex = 0;
    }

    if($maxDisplayIndex == -1)
    {
      $maxDisplayIndex = $maxIndex;
    }
    
    my $decodedDataHex = "";
    my $decodedDataCharString = "";
    my $displayArrayStarted = 0;
    my $savedDecodedData = "";
    my $savedDecodedDataHex = "";
    my $savedDecodedDataText = "";
    my $savedDisplayArrayStarted = 0;
    my $index = 0;
    while($index < $maxIndex)
    {
      if($showIndex && $index == $maxDisplayIndex)
      {
        $savedDecodedData = $decodedData;
        $savedDecodedDataHex = $decodedDataHex;
        $savedDecodedDataText = $decodedDataText;
        $savedDisplayArrayStarted = $displayArrayStarted;
      }

      my $showPosition = "";
      if($settings{position})
      {
        # show position in memory for each attribute
        my $positionU8 = ($signalDataLength - length $signalData) / 2;
        my $positionU16 = ($signalDataLength - length $signalData) / 4;
        $showPosition = sprintf("%.4x %.4x ", $positionU8, $positionU16);
      }

      my $decodedAttribute = "";
      my $decodedAttributeHex = "";
      if($showIndex)
      {
        if($compressArray)
        {
          $attributeName = "$origAttributeName\[\]";
        }
        else
        {
          $attributeName = "$origAttributeName\[$index\]";
        }
      }
      
      my $sizeLeftBeforeDecoding = length($signalData);
      
      if($attributeType =~ /\*/)  # the attribute is a pointer
      {
        if($attributeType =~ /\_\_cm/)
        {
          my $byte1 = getNextByte(\$decodedData);
          my $byte2 = getNextByte(\$decodedData);
          my $byte3 = getNextByte(\$decodedData);
          my $byte4 = getNextByte(\$decodedData);
          $attributeValue = hex($byte1) * 16777216 + hex($byte2) * 65536 + hex($byte3) * 256 + hex($byte4);
          $decodedAttribute = "0x$byte1$byte2$byte3$byte4";
          $decodedAttributeHex = "$byte1 $byte2 $byte3 $byte4";
        }
        else
        {
          my $byte1 = getNextByte(\$decodedData);
          my $byte2 = getNextByte(\$decodedData);
          $attributeValue = hex($byte1) * 256 + hex($byte2);
          $decodedAttribute = "0x$byte1$byte2";
          $decodedAttributeHex = "$byte1 $byte2";
        }
      }
      elsif($attributeType =~ /(.*?)\:(\d+)/)  # the attribute is bit divided
      {
        my ($attributeTypeFixed, $bitLength) = ($1, $2);

        if($bitLeft == 0)
        {
          if($attributeTypeFixed eq "U32" ||
             $attributeTypeFixed eq "S32")
          {
            if($signalDataPlatform eq "cpp")
            {
              # if CPP platform, make sure we start read U32/S32 from the right byte, there might be padding
              while(($readBytes % 4) != 0)
              {
                my $padding = getNextByte(\$decodedData);
                $readBytes++;
              }
            }
            
            $bitLeft = 2147483648;
            my $byte1 = getNextByte(\$decodedData);
            my $byte2 = getNextByte(\$decodedData);
            my $byte3 = getNextByte(\$decodedData);
            my $byte4 = getNextByte(\$decodedData);
            $attributeValueAllBits = hex($byte1) * 16777216 + hex($byte2) * 65536 + hex($byte3) * 256 + hex($byte4);
          }
          elsif($attributeTypeFixed eq "U16" ||
                $attributeTypeFixed eq "S16" ||
                $attributeTypeFixed eq "short" ||
                $attributeTypeFixed eq "int")
          {
            $bitLeft = 32768;
            my $byte1 = getNextByte(\$decodedData);
            my $byte2 = getNextByte(\$decodedData);
            $attributeValueAllBits = hex($byte1) * 256 + hex($byte2);
          }
          elsif($attributeTypeFixed eq "U8" ||
                $attributeTypeFixed eq "CHAR" ||
                $attributeTypeFixed eq "char")
          {
            $bitLeft = 128;
            my $byte = getNextByte(\$decodedData);
            $attributeValueAllBits = hex($byte);
          }
          else  # unknown attribute type
          {
            $decodedAttribute = "(Unknown type $attributeTypeFixed)";
            $decodedData .= "Decoder warning: Size of next attribute unknown, rest of data is probably incorrect\n";
          }
        }
        
        my $bits = "";
        while($bitLength > 0)
        {
          my $bit = ($attributeValueAllBits & $bitLeft) > 0 ? 1 : 0;
          $bits .= $bit;
          $bitLeft = ($bitLeft == 1) ? 0 : $bitLeft / 2;
          $bitLength--;
        }
	$attributeValue = binToDec($bits);
        $decodedAttribute = $attributeValue;
      }
      else  # normal attribute
      {
        $bitLeft = 0;
        
        if($attributeType eq "U64" ||
           $attributeType eq "S64")
        {
          my $byte1 = getNextByte(\$decodedData);
          my $byte2 = getNextByte(\$decodedData);
          my $byte3 = getNextByte(\$decodedData);
          my $byte4 = getNextByte(\$decodedData);
          my $byte5 = getNextByte(\$decodedData);
          my $byte6 = getNextByte(\$decodedData);
          my $byte7 = getNextByte(\$decodedData);
          my $byte8 = getNextByte(\$decodedData);
          $attributeValue = hex($byte1) * 16777216 + hex($byte2) * 65536 + hex($byte3) * 256 + hex($byte4);
          $attributeValue = $attributeValue * 4294967296 + hex($byte5) * 16777216 + hex($byte6) * 65536 + hex($byte7) * 256 + hex($byte8);
          if($attributeType eq "S64") {$attributeValue = getTwoComplement(64, $attributeValue);}
          $decodedAttribute = "$attributeValue (0x$byte1$byte2$byte3$byte4$byte5$byte6$byte7$byte8)";
          $decodedAttributeHex = "$byte1 $byte2 $byte3 $byte4 $byte5 $byte6 $byte7 $byte8";
        }
        elsif($attributeType eq "U32" ||
              $attributeType eq "S32")
        {
          if($signalDataPlatform eq "cpp")
          {
            # if CPP platform, make sure we start read U32/S32 from the right byte, there might be padding
            while(($readBytes % 4) != 0)
            {
              my $padding = getNextByte(\$decodedData);
              $readBytes++;
            }
          }

          my $byte1 = getNextByte(\$decodedData);
          my $byte2 = getNextByte(\$decodedData);
          my $byte3 = getNextByte(\$decodedData);
          my $byte4 = getNextByte(\$decodedData);
          $attributeValue = hex($byte1) * 16777216 + hex($byte2) * 65536 + hex($byte3) * 256 + hex($byte4);
          if($attributeType eq "S32") {$attributeValue = getTwoComplement(32, $attributeValue);}
          if(defined $displayVariabelAlsoAsHex{$attributeName})
          {
            $decodedAttribute = "$attributeValue (0x$byte1$byte2$byte3$byte4)";
          }
          else
          {
            $decodedAttribute = "$attributeValue";
          }
          $decodedAttributeHex = "$byte1 $byte2 $byte3 $byte4";
        }
        elsif($attributeType eq "enum")
        {
          my $byte1 = getNextByte(\$decodedData);
          my $byte2 = getNextByte(\$decodedData);
          $attributeValue = hex($byte1) * 256 + hex($byte2);
          my $enumVariabelName = $enumValue{$origAttributeType, $attributeValue};
          if($enumVariabelName eq "") {$enumVariabelName = "unknown enum value";}
          $decodedAttribute = "$attributeValue ($enumVariabelName)";
          $decodedAttributeHex = "$byte1 $byte2";
        }
        elsif($attributeType eq "U16" ||
              $attributeType eq "S16" ||
              $attributeType eq "short" ||
              $attributeType eq "int")
        {
          my $byte1 = getNextByte(\$decodedData);
          my $byte2 = getNextByte(\$decodedData);
          if(($attributeName !~ /^padding\d+$/ && $attributeName !~ /^dummy/) || $showPaddingAttributes)
          {
            $attributeValue = hex($byte1) * 256 + hex($byte2);
            if($attributeType eq "S16") {$attributeValue = getTwoComplement(16, $attributeValue);}
            $decodedAttribute = "$attributeValue";
            $decodedAttributeHex = "$byte1 $byte2";
          }
        }
        elsif($attributeType eq "U8" ||
              $attributeType eq "CHAR" ||
              $attributeType eq "char")
        {
          my $byte = getNextByte(\$decodedData);
          $attributeValue = hex($byte);
          $decodedAttribute = "$attributeValue";
          $decodedAttributeHex = "$byte";
          $decodedDataCharString .= sprintf("%c", $attributeValue);
        }
        elsif($attributeType eq "__accum" || $attributeType eq "signed __accum" || $attributeType eq "unsigned __accum")
        {
          my $byte1 = getNextByte(\$decodedData);
          my $byte2 = getNextByte(\$decodedData);
          my $byte3 = getNextByte(\$decodedData);
          my $byte4 = getNextByte(\$decodedData);
          $attributeValue = hex($byte1) * 16777216 + hex($byte2) * 65536 + hex($byte3) * 256 + hex($byte4);
          $attributeValue = $attributeValue & 0xffffff;  # __accum is 24 LSB
          if($attributeType ne "unsigned __accum") {$attributeValue = getTwoComplement(24, $attributeValue);}
          $decodedAttribute = $attributeValue / $power2_15;
          $decodedAttributeHex = "$byte1 $byte2 $byte3 $byte4";
          $decodedDataHex = "0x$byte1$byte2$byte3$byte4";
        }
        elsif($attributeType eq "long __accum" || $attributeType eq "signed long __accum" || $attributeType eq "unsigned long __accum")
        {
          my $byte1 = getNextByte(\$decodedData);
          my $byte2 = getNextByte(\$decodedData);
          my $byte3 = getNextByte(\$decodedData);
          my $byte4 = getNextByte(\$decodedData);
          my $byte5 = getNextByte(\$decodedData);
          my $byte6 = getNextByte(\$decodedData);
          # long __accum is 40 LSB
          $attributeValue = hex($byte2) * 4294967296 + hex($byte3) * 16777216 + hex($byte4) * 65536 + hex($byte5) * 256 + hex($byte6);
          $decodedAttribute = hex($byte2) * 2 + (hex($byte3) * 256 + hex($byte4)) / $power2_15 + (hex($byte5) * 256 + hex($byte6)) / $power2_31;
          if($attributeType ne "unsigned long __accum" && hex($byte2) >= 128)
          {
            $decodedAttribute -= 512;
          }
          $decodedAttributeHex = "$byte1 $byte2 $byte3 $byte4 $byte5 $byte6";
          $decodedDataHex = "0x$byte1$byte2$byte3$byte4$byte5$byte6";
        }
        elsif($attributeType eq "__fixed" || $attributeType eq "signed __fixed" || $attributeType eq "unsigned __fixed")
        {
          my $byte1 = getNextByte(\$decodedData);
          my $byte2 = getNextByte(\$decodedData);
          $attributeValue = hex($byte1) * 256 + hex($byte2);
          if($attributeType ne "unsigned __fixed") {$attributeValue = getTwoComplement(16, $attributeValue);}
          $decodedAttribute = $attributeValue / $power2_15;
          $decodedAttributeHex = "$byte1 $byte2";
          $decodedDataHex = "0x$byte1$byte2";
        }
        elsif($attributeType eq "long __fixed" || $attributeType eq "signed long __fixed" || $attributeType eq "unsigned long __fixed")
        {
          my $byte1 = getNextByte(\$decodedData);
          my $byte2 = getNextByte(\$decodedData);
          my $byte3 = getNextByte(\$decodedData);
          my $byte4 = getNextByte(\$decodedData);
          $attributeValue = hex($byte1) * 16777216 + hex($byte2) * 65536 + hex($byte3) * 256 + hex($byte4);
          if($attributeType ne "unsigned __fixed") {$attributeValue = getTwoComplement(32, $attributeValue);}
          $decodedAttribute = $attributeValue / $power2_31;
          $decodedAttributeHex = "$byte1 $byte2 $byte3 $byte4";
          $decodedDataHex = "0x$byte1$byte2$byte3$byte4";
        }
        elsif(defined $structAttributes{$attributeType})  # attribute type is a known struct
        {
          if($compactOutput && $nrOfAttributes > 1)
          {
            $decodedData .= ", ";
          }

          if($compactOutput)
          {
            $decodedData .= "$showPosition$showType$attributeName { ";
            $decodedData .= decodeStruct($attributeType, "$attributePath$attributeName.", $level + 1, "$intendentation  ", $insideUnion);
            $decodedData .= " }";
          }
          else
          {
            if(($level + 1) >= $settings{compactlevel})
            {
              # next level will have compact output
              $decodedData .= "$showPosition$intendentation$showType$attributeName { ";
              $decodedData .= decodeStruct($attributeType, "$attributePath$attributeName.", $level + 1, "$intendentation  ", $insideUnion);
              $decodedData .= " }\n";
            }
            else
            {
              $decodedData .= "$showPosition$intendentation$showType$attributeName {\n";
              $decodedData .= decodeStruct($attributeType, "$attributePath$attributeName.", $level + 1, "$intendentation  ", $insideUnion);
              my $intendentationDueToPosition = substr $spaces, 0, length "$showPosition";
              $decodedData .= "$intendentationDueToPosition$intendentation}\n";
            }
          }
        }
        else  # unknown attribute type
        {
          $decodedAttribute = "(Unknown type $attributeType)";
          $decodedData .= "Decoder warning: Size of next attribute unknown, rest of data is probably incorrect\n";
        }
      }
    
      if($signalDataEmptyWarningDisplayed)
      {
        return $decodedData;
      }
      
      # if attribute has been decoded, display the result
      if($decodedAttribute ne "")
      {
        if($compactOutput && $nrOfAttributes > 1 && $index == 0)
        {
          $decodedData .= ", ";
        }

        if($showIndex && $compressArray)
        {
          if($index == 0)
          {
            if(!$compactOutput) {$decodedData .= "$showPosition$intendentation";}
            $decodedData .= "$showType$attributeName = \[$decodedAttribute";
            $intendentationToData = substr $spaces, 0, length "$showPosition$intendentation$showType$attributeName = ";
            $decodedDataHex = "\[$decodedAttributeHex";
            $displayArrayStarted = 1;
          }
          else
          {
            $decodedData .= ", $decodedAttribute";
            $decodedDataHex .= " $decodedAttributeHex";
          }
        }
        else
        {
          if(!$compactOutput) {$decodedData .= "$showPosition$intendentation";}
          $decodedData .= "$showType$attributeName = $decodedAttribute";
          if($displayArrayStarted == 0 && $decodedDataHex ne "") {$decodedData .= " ($decodedDataHex)";}
          if(!$compactOutput) {$decodedData .= "\n";}
        }
        
        my $saveAttributeName = $showIndex ? "$attributePath$origAttributeName\[$index\]" : "$attributePath$origAttributeName";
        $savedDecodedAttributeFullPath{$saveAttributeName} = $decodedAttribute;
        $decodedDataText .= "$saveAttributeName: $decodedAttribute, ";
        $currentStructStructure .= "$saveAttributeName,";
      }

      $index++;

      my $sizeThisAttribute = $sizeLeftBeforeDecoding - length($signalData);
      if($showIndex && $nrOfAttributes == $totalNrOfAttributes && $index == $maxIndex && $level == 1 &&
         $signalData ne "" && $sizeThisAttribute > 0 && (length($signalData) % $sizeThisAttribute == 0))
      {
        # since this is an array with variable number of elements last in the top struct and the length of the remaining
        # signal data could be more elements of this array (size matches 1..many of this attributes) also decode them
        $maxIndex++;
        if($settings{showallelements})
        {
          $maxDisplayIndex++;
        }
      } 
    }
    
    if($showIndex && $maxDisplayIndex != -1 && $index > $maxDisplayIndex)
    {
      $decodedData = $savedDecodedData;
      $decodedDataHex = $savedDecodedDataHex;
      $decodedDataText = $savedDecodedDataText;
      $displayArrayStarted = $savedDisplayArrayStarted;
    }

    if($displayArrayStarted == 1)
    {
      $decodedData .= "\]";
      $decodedDataHex .= "\]";
      if(!$compactOutput && ($decodedDataCharString ne "" || $decodedDataHex ne "")) {$decodedData .= "dec";}
      if($decodedDataCharString ne "")
      {
        $decodedDataCharString =~ s/(.*?)\0.*/$1/;
        if($compactOutput)
        {
          $decodedData .= " as text: \"$decodedDataCharString\"";
        }
        else
        {
          $decodedData .= "\n$intendentationToData\"$decodedDataCharString\"text";
        }
      }
      if($decodedDataHex ne "")
      {
        if($compactOutput)
        {
          $decodedData .= " as hex: $decodedDataHex";
        }
        else
        {
          $decodedData .= "\n$intendentationToData${decodedDataHex}hex";
        }
      }
      if(!$compactOutput) {$decodedData .= "\n";}
    }

    if($attributeName !~ /^padding/)
    {
      $lastAttributeName = $attributeName;
      $lastAttributeValue = $attributeValue;
    }

    if($isUnion)
    {
      # check if this union is the largest, the largest union have least signal data left
      if($signalDataAfterLargestUnion eq "-" || length($signalData) < length($signalDataAfterLargestUnion))
      {
        $signalDataAfterLargestUnion = $signalData;
      }
      
      # union => reset signal data for each attribute
      $signalData = $savedSignalData;
      
      if((defined $unionAttributeDisplaySetting{$structName} && $unionAttributeAlreadyShown) ||
         !showUnionAttribute($structName, $attributeName))
      {
        # reset decoded data to what is was before this attribute was decoded
        $decodedData = $savedDecodedDataForUnion;
        $decodedDataText = $savedDecodedDataTextForUnion;
        %savedDecodedAttributeFullPath = %savedDecodedAttributeFullPathForUnion;
      }
      else
      {
        # do not reset the decoded data for this attribute
        $unionAttributeAlreadyShown = 1;
      }
    }

    $savedAttributeValue{$attributeNameShort} = $attributeValue;
    $savedAttributeValueFullPath{"$attributePath$attributeName"} = $attributeValue;
  }

  if($isUnion)
  {
    $signalData = $signalDataAfterLargestUnion;
  }

  if($signalDataPlatform eq "cpp" && $level == 1 && (length $signalData) == 4)
  {
    # if CPP platform, there might be padding in the end
    my $readBytes = ($startLength - length $signalData) / 2;
    if(($readBytes % 4) != 0)
    {
      my $padding1 = getNextByte(\$decodedData);
      my $padding2 = getNextByte(\$decodedData);
    }
  }
  
  return $decodedData;
}


sub getNextByte
{
  my ($decodedDataRef) = @_;
  
  # read next byte from the signal data
  if((length $signalData) >= 2)
  {
    return substr $signalData, 0, 2, "";
  }
  
  if(!$signalDataEmptyWarningDisplayed)
  {
    $signalDataEmptyWarningDisplayed = 1;
    $$decodedDataRef .= "Decoder warning: No more signal data found to decode\n";
  }
  return 0;
}


sub showUnionAttribute
{
  my($structName, $attributeName) = @_;

  if(defined $unionAttributeDisplaySetting{$structName})
  {
    # special setting exists for this union, check setting
    foreach my $setting (split(/,/, $unionAttributeDisplaySetting{$structName}))
    {
      if($setting =~ /(.*?):(.*)/)
      {
        my($unionAttributeName, $lengthAttributeName) = ($1, $2);
        if($unionAttributeName eq $attributeName)
        {
          if($savedAttributeValueFullPath{$lengthAttributeName} - $unionAttributeDisplayed{$structName, $unionAttributeName} > 0)
          {
            # more of this union attribute should be displayed
            $unionAttributeDisplayed{$structName, $unionAttributeName}++;
            return 1;
          }
          else
          {
            # no more of this union attribute should be displayed
            return 0;
          }
        }
      }
    }
  }

  # no settings found for this union and attribute, show it
  return 1;
}


# ------------- Decode PDU ------------------------------------------------------------------------------------


sub decodePdu
{
  my ($signalName, $signalDataLines, $level, $intendentation) = @_;

  if($settings{dct2000} ne "")
  {
    if($signalName =~ /mac/i)
    {
      my $cellId = 0;
      if($signalTraceLine =~ /cellid (\d+)/i)
      {
        # reduce to 6 bits (0..63) since wireshark don't accept values >= 100
        $cellId = $1 & 0x3f;
      }
      my $rntiType = 3;
      my $direction = ($signalTraceLine =~ /dlmac/i) ? 1 : 0;
      my $subframe = 0;
      my $ueid = 0;
      my $timeStamp = ($signalTraceLine =~ /(0x[0-9a-fA-F]+)/) ? decodeRadioTimeToSeconds($1) : "0.0";
      my $pduLength = ($signalTraceLine =~ /Length[=:](\d+)/i || $signalTraceLine =~ /size (\d+)/i) ? $1 : 0;
      my $receivedSent = ($signalTraceLine =~ /send/i) ? "s" : "r";
      my $signalDataLc = lc $signalData;

      print DCTFILE "macpe.$cellId/mac_r8_lte/1,1,$rntiType,$direction,$subframe,0,0,$ueid,$pduLength,0/// $receivedSent tm $timeStamp l \$$signalDataLc\n";
      # DCT2000, MAC parameters:
      # 1, Protocol version
      # 2, Radio Type: FDD(1), TDD(2)
      # 3, RNTI Type: NO-RNTI(0), P-RNTI(1), RA-RNTI(2), C-RNTI(3), SI-RNTI(4)
      # 4, Direction: Uplink(0), Downlink(1)
      # 5, Subframe
      # 6, Predefined frame: Real MAC PDU present - will dissect (0), Predefined frame present - will not dissect (1)
      # 7, RNTI
      # 8, UEId
      # 9, Length of frame
      # 10, ReTX count (retransmission count)
    }
    elsif($signalName =~ /rlc/i)
    {
      my $channelType = 0;
      if($signalName =~ /srb/i)
      {
        $channelType = 4;
      }
      elsif($signalName =~ /drb/i)
      {
        $channelType = 5;
      }
      
      my $bbBearerRef = ($signalTraceLine =~ /bbBearerRef=(\d+) /) ? ($1 + 1) & 0x1f : -1;
      my $rbId = ($signalTraceLine =~ /rbId=(\d+) /) ? $1 : -1;
      my $pduLength = ($signalTraceLine =~ /Length[=:](\d+)/i || $signalTraceLine =~ /size (\d+)/i) ? $1 : 0;
      my $timeStamp = ($signalTraceLine =~ /(0x[0-9a-fA-F]+)/) ? decodeRadioTimeToSeconds($1) : "0.0";
      my $direction = ($signalTraceLine =~ /dlrlc/i) ? 1 : 0;
      my $receivedSent = ($signalTraceLine =~ /send/i) ? "s" : "r";
      my $signalDataLc = lc $signalData;

      if(($direction == 1 && $signalTraceLine =~ /bin_rec/i) ||
         ($direction == 0 && $signalTraceLine =~ /bin_send/i))
      {
        # remove traces that are traced both on dlRlcPe and ulRlcPe. Keep send traces from dlRlcPe and receive traces from ulRlcPe.
      }
      else
      {
        print DCTFILE "rlcpe.$rbId/rlc_r8_lte/1,4,$direction,0,0,$bbBearerRef,$channelType,0,$pduLength,0/// $receivedSent tm $timeStamp l \$$signalDataLc\n";
      }

      # DCT2000, RLC parameters:
      # 1, Protocol version
      # 2, RLC Mode: TM(1), UM(2), AM(4)
      # 3, Direction: Uplink(0), Downlink(1)
      # 4, ?,
      # 5, ?,
      # 6, ?, here used for bbBearerRef,
      # 7, Channel type: CCCH(1), BCCH(2), PCCH(3), SRB(4), DRB(5)
      # 8, ueId,
      # 9, pduLength,
      # 10, ?
    }
  }

  $pduAttributeNr = 1;
  my $decodedData = "";

  if($signalName eq "rlcdrbpdu")
  {
    my $rlcMode = ($signalTraceLine =~ /rlcMode=(\d+)/) ? $1 : 0;
    my $rlcSnLength = ($signalTraceLine =~ /rlcSNLength=(\d+)/) ? $1 : -1;
    $decodedData = decodeRlcPduFromHex($signalData, $level, $intendentation, $rlcMode, $rlcSnLength, "DRB");
  }
  elsif($signalName eq "rlcsrbpdu")
  {
    my $rlcMode = ($signalTraceLine =~ /rlcMode=(\d)/) ? $1 : 0;
    my $rlcSnLength = ($signalTraceLine =~ /rlcSNLength=(\d+)/) ? $1 : -1;
    $decodedData = decodeRlcPduFromHex($signalData, $level, $intendentation, $rlcMode, $rlcSnLength, "SRB");
  }
  elsif($signalName eq "pdcpdrbpdu")
  { my $rohcMode = ($signalTraceLine =~ /rohcEnabled=(\d)/) ? $1 : 0;
    my $pdcpSnLength = ($signalTraceLine =~ /pdcpSNLength=(\d+)/) ? $1 : 12;
    $decodedData = decodePdcpPduFromHex($signalData, $level, $intendentation, $rohcMode, $pdcpSnLength, "DRB");
  }
  elsif($signalName eq "pdcpsrbpdu")
  {
    my $rohcMode = ($signalTraceLine =~ /rohcEnabled=(\d)/) ? $1 : 0;
    my $pdcpSnLength = ($signalTraceLine =~ /pdcpSNLength=(\d+)/) ? $1 : 12;
    $decodedData = decodePdcpPduFromHex($signalData, $level, $intendentation, $rohcMode, $pdcpSnLength, "SRB"); 
  }
  elsif($signalName eq "dlmacpdu")
  {
    $decodedData = decodeMacPduFromHex($signalData, $level, $intendentation, "DL");
  }
  elsif($signalName eq "ulmacpdu")
  {
    $decodedData = decodeMacPduFromHex($signalData, $level, $intendentation, "UL");
  }
  elsif($signalName eq "rrcpdu")
  {
    $decodedData = decodeRrcPduFromHex($signalData, $level, $intendentation);
  }
  elsif($signalName eq "rohc")
  {
    $decodedData = decodePdcpPduFromHex($signalData, $level, $intendentation, 1, -1, "DRB");
  }
  elsif($signalName eq "rohcfb")
  {
    $decodedData = decodePdcpPduFromHex($signalData, $level, $intendentation, 1, 12, "DRB");
  }

  elsif($signalName eq "gtpu")
  {
    $decodedData = decodeGtpuFromHex($signalData, $level, $intendentation);
  }
  elsif($signalName eq "sctp")
  {
    $decodedData = decodeSctpFromHex($signalData, $level, $intendentation);
  }
  elsif($signalName eq "ip")
  {
    $decodedData = decodeIpFromHex($signalData, $level, $intendentation);
  }

  # show encoded hex data
  if($signalDataLines ne "")
  {
    print $FO $signalDataLines;
    print $FO $decodedData;
  }
  else
  {
    return $decodedData;
  }
}


sub isPdu
{
  my ($structOrSignalName) = @_;
  return $structOrSignalName =~ /^(?:rlcdrbpdu|rlcsrbpdu|pdcpdrbpdu|pdcpsrbpdu|dlmacpdu|ulmacpdu|gtpu|sctp|ip|rohc|rohcfb)$/;
}


# ------------- Decode RRC PDU ------------------------------------------------------------------------------------


sub decodeRrcPduFromHex
{
  my ($pduHexData, $level, $intendentation) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  my $compactOutputNextLevel = ($level + 1) >= $settings{compactlevel} ? 1 : 0;

  my $decodedData = $compactOutput ? "RRC PDU {" : "${intendentation}RRC PDU {";
  $decodedData .= $compactOutputNextLevel ? " " : "\n";
  $pduHexData =~ s/(..)/$1 /g;
  $decodedData .= $compactOutput ? "$pduHexData" : "${intendentation}  $pduHexData\n";
  $decodedData .= $compactOutput ? " } " : "${intendentation}}\n";

  return $decodedData;
}


# ------------- Decode MAC PDU ------------------------------------------------------------------------------------


sub decodeMacPduFromHex
{
  my ($pduHexData, $level, $intendentation, $direction) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  my $compactOutputNextLevel = ($level + 1) >= $settings{compactlevel} ? 1 : 0;
  my $savedPduBitData = $pduBitData;
  $pduBitData = hexToBin($pduHexData);

  my $decodedData = $compactOutput ? "MAC PDU {" : "${intendentation}MAC PDU {";
  $decodedData .= $compactOutputNextLevel ? " " : "\n";
  $decodedData .= decodeMacPdu($level + 1, "$intendentation  ", $direction);
  $decodedData .= $compactOutput ? " } " : "${intendentation}}\n";

  $pduBitData = $savedPduBitData;
  
  return $decodedData;
}


sub decodeMacPdu
{
  my ($level, $intendentation, $direction) = @_;
  # expects pdu to be stored in global variable $pduBitData

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  my $decodedData = "";

  my %payloadSize;
  my %payloadType;
  my $nrOfHeaders = 0;
  my $origIntendentation = $intendentation;
  $pduAttributeNr = 1;

  my $E;
  do {
    $nrOfHeaders++;

    $decodedData .= $compactOutput ? "Subheader $nrOfHeaders { " : "${intendentation}Subheader $nrOfHeaders {\n";
    $intendentation = "$intendentation  ";
    nextPduFieldBit(\$decodedData, $level, $intendentation, "Reserved bits", 2);

    my %values = (
      0 => "Either a MAC SDU, a MAC control element or padding starts at the next byte",
      1 => "Another set of at least R/R/E/LCID fields follows",
    );
    $E = nextPduFieldMapBit(\$decodedData, $level, $intendentation, "E", 1, \%values);

    my ($LCID, $fixedSize);
    if($direction eq "DL")
    {
      ($LCID, $fixedSize) = decodeMacPduLcidDl(\$decodedData, $level, $intendentation);
    }
    else
    {
      ($LCID, $fixedSize) = decodeMacPduLcidUl(\$decodedData, $level, $intendentation);
    }
    my $fixedSizeControlElementOrPadding = $fixedSize ne "" || $LCID eq "11111";
    $payloadType{$nrOfHeaders} = $LCID;
    $payloadSize{$nrOfHeaders} = $fixedSize;

    if($E == 1 && $fixedSizeControlElementOrPadding == 0)
    {
      my %values = (
        0 => "The size of the MAC SDU or MAC control element is less than 128 bytes",
        1 => "The size of the MAC SDU or MAC control element is equal to or greater than 128 bytes",
      );
      my $F = nextPduFieldMapBit(\$decodedData, $level, $intendentation, "F", 1, \%values);

      my $L;
      if($F == 0)
      {
        $L = nextPduField(\$decodedData, $level, $intendentation, "L", 7);
      }
      else
      {
        $L = nextPduField(\$decodedData, $level, $intendentation, "L", 15);
      }
      $payloadSize{$nrOfHeaders} = $L * 8;  # bits
    }

    $intendentation = $origIntendentation;
    $decodedData .= $compactOutput ? "} " : "${intendentation}}\n";
  } while ($E == 1);

  $pduAttributeNr = 1;
  my $headerNr = 0;
  while($headerNr < $nrOfHeaders)
  {
    $headerNr++;

    my $size = $payloadSize{$headerNr};
    if($size eq "")
    {
      # last payload (if not a control element)
      $size = length $pduBitData;
    }

    nextPduFieldHex(\$decodedData, $level, $intendentation, "Payload $headerNr", $size);
  }
  
  return $decodedData;
}


sub decodeMacPduLcidDl
{
  my ($decodedDataRef, $level, $intendentation) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
  $pduAttributeNr++;

  my $bits = getNextPduBits($decodedDataRef, 5);
  my $value = binToDec($bits);
  my %values = (
    "00000" => "CCCH",
    "11100" => "UE Contention Resolution Identity",
    "11101" => "Timing Advance Command",
    "11110" => "DRX Command",
    "11111" => "Padding",
  );
  my $valueName = "";
  if(defined $values{$bits})
  {
    $valueName = $values{$bits};
  }
  elsif($value <= 10)
  {
    $valueName = "Identity of the logical channel: $value";
  }
  else
  {
    $valueName = "INVALID VALUE";
  }
  $$decodedDataRef .= $compactOutput ? "LCID = $valueName ($bits)" : "${intendentation}LCID = $valueName ($bits)\n";
  
  my %fixedSize = (
    "11100" => 48,  # UE Contention Resolution Identity
    "11101" => 8,   # Timing Advance Command
    "11110" => 0,   # DRX Command
  );
  my $fixedSize = "";
  if(defined $fixedSize{$bits})
  {
    $fixedSize = $fixedSize{$bits};
  }

  return ($bits, $fixedSize);
}


sub decodeMacPduLcidUl
{
  my ($decodedDataRef, $level, $intendentation) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
  $pduAttributeNr++;

  my $bits = getNextPduBits($decodedDataRef, 5);
  my $value = binToDec($bits);
  my %values = (
    "00000" => "CCCH",
    "11010" => "Power Headroom Report",
    "11011" => "C-RNTI",
    "11100" => "Truncated BSR",
    "11101" => "Short BSR",
    "11110" => "Long BSR",
    "11111" => "Padding",
  );
  my $valueName = "";
  if(defined $values{$bits})
  {
    $valueName = $values{$bits};
  }
  elsif($value <= 10)
  {
    $valueName = "Identity of the logical channel: $value";
  }
  else
  {
    $valueName = "INVALID VALUE";
  }
  $$decodedDataRef .= $compactOutput ? "LCID = $valueName ($bits)" : "${intendentation}LCID = $valueName ($bits)\n";

  my %fixedSize = (
    "11010" => 8,   # Power Headroom Report
    "11011" => 16,  # C-RNTI
    "11100" => 8,   # Truncated BSR
    "11101" => 8,   # Short BSR
    "11110" => 24,  # Long BSR
  );
  my $fixedSize = "";
  if(defined $fixedSize{$bits})
  {
    $fixedSize = $fixedSize{$bits};
  }
  
  return ($bits, $fixedSize);
}


# ------------- Decode RLC PDU ------------------------------------------------------------------------------------


sub decodeRlcPduFromHex
{
  my ($pduHexData, $level, $intendentation, $rlcMode, $rlcSnLength, $type) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  my $compactOutputNextLevel = ($level + 1) >= $settings{compactlevel} ? 1 : 0;
  my $savedPduBitData = $pduBitData;
  $pduBitData = hexToBin($pduHexData);
  
  my $decodedData = $compactOutput ? "RLC PDU {" : "${intendentation}RLC PDU {";
  $decodedData .= $compactOutputNextLevel ? " " : "\n";
  $decodedData .= decodeRlcPdu($level + 1, "$intendentation  ", $rlcMode, $rlcSnLength, $type);
  $decodedData .= $compactOutput ? " } " : "${intendentation}}\n";
  
  $pduBitData = $savedPduBitData;
  
  return $decodedData;
}


sub decodeRlcPdu
{
  my ($level, $intendentation, $rlcMode, $rlcSnLength, $type) = @_;
  # expects pdu to be stored in global variable $pduBitData

  my $decodedData = "";


  if($rlcMode == 0)
  {
    # AM PDU
    my %values = (
      0 => "Control PDU",
      1 => "Data PDU",
    );
    if(nextPduFieldMapBit(\$decodedData, $level, $intendentation, "D/C", 1, \%values) == 0)
    {
      decodeRlcControlPdu(\$decodedData, $level, $intendentation, $type);
    }
    else
    {
      decodeRlcAmdPdu(\$decodedData, $level, $intendentation, $type);
    }
  }
  elsif($rlcMode == 1)
  {
    # UM PDU
    decodeRlcUmdPdu(\$decodedData, $level, $intendentation, $rlcSnLength, $type);
  }
  else
  {
     $decodedData .= "Decoder warning: Unknown rlcMode=$rlcMode\n";
     nextPduFieldRestHex(\$decodedData, $level, $intendentation, "RLC PDU");
  }
  
  return $decodedData;
}


sub decodeRlcControlPdu
{
  my ($decodedDataRef, $level, $intendentation, $type) = @_;

  my %values = (
    "000" => "STATUS PDU"
  );
  nextPduFieldMapBit($decodedDataRef, $level, $intendentation, "CPT", 3, \%values);

  nextPduField($decodedDataRef, $level, $intendentation, "ACK_SN", 10);

  my %values = (
    0 => "A set of NACK_SN, E1 and E2 does not follow",
    1 => "A set of NACK_SN, E1 and E2 follows",
  );
  my $E1 = nextPduFieldMapBit($decodedDataRef, $level, $intendentation, "E1", 1, \%values);

  while($E1 == 1)
  {
    nextPduField($decodedDataRef, $level, $intendentation, "NACK_SN", 10);

    my %values = (
      0 => "A set of NACK_SN, E1 and E2 does not follow",
      1 => "A set of NACK_SN, E1 and E2 follows",
    );
    $E1 = nextPduFieldMapBit($decodedDataRef, $level, $intendentation, "E1", 1, \%values);

    my %values = (
      0 => "A set of SOstart and SOend does not follow for this NACK_SN",
      1 => "A set of SOstart and SOend follows for this NACK_SN",
    );
    if(nextPduFieldMapBit($decodedDataRef, $level, $intendentation, "E2", 1, \%values) == 1)
    {
      nextPduField($decodedDataRef, $level, $intendentation, "SOstart", 15);
      nextPduField($decodedDataRef, $level, $intendentation, "SOend", 15);
    }
  }
}


sub decodeRlcUmdPdu
{
  my ($decodedDataRef, $level, $intendentation, $rlcSnLength, $type) = @_;

  my %fi_values = (
    "00" => "First byte starts SDU, Last byte ends SDU",
    "01" => "First byte starts SDU, Last byte does NOT end SDU",
    "10" => "First byte does NOT start SDU, Last byte ends SDU",
    "11" => "First byte does NOT start SDU, Last byte does NOT end SDU",
  );

  my $E;
  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  my $pduBitLengthBeforeHeader = (length $pduBitData);

  if($rlcSnLength == 5)
  {
    nextPduFieldMapBit($decodedDataRef, $level, $intendentation, "FI", 2, \%fi_values);
    $E = nextPduField($decodedDataRef, $level, $intendentation, "Extension(E)", 1);
    nextPduField($decodedDataRef, $level, $intendentation, "RLC SN", 5);
  }
  elsif($rlcSnLength == 10)
  {
    nextPduField($decodedDataRef, $level, $intendentation, "Reserved", 3);
    nextPduFieldMapBit($decodedDataRef, $level, $intendentation, "FI", 2, \%fi_values);
    $E = nextPduField($decodedDataRef, $level, $intendentation, "Extension(E)", 1);
    nextPduField($decodedDataRef, $level, $intendentation, "RLC SN", 10);
  }

  my %payloadSize;
  my %payloadType;
  my $nrOfHeaders = 0;
  my $totalPayloadSizeFirstSdus = 0;
  
  if($E == 1)
  {
    # A set of E field and LI field follows
    while($E == 1)
    {
      $E = nextPduField($decodedDataRef, $level, $intendentation, "Extension(E)", 1);

      $nrOfHeaders++;
      my $LI = nextPduField($decodedDataRef, $level, $intendentation, "LI (RLC SDU $nrOfHeaders)", 11);

      $payloadSize{$nrOfHeaders} = $LI * 8;  # in bits
      $totalPayloadSizeFirstSdus += $LI;     # in bytes
    }
    
    if($nrOfHeaders % 2 == 1)
    {
      # odd number of LI, 4 bits padding
      nextPduFieldBit($decodedDataRef, $level, $intendentation, "Padding", 4);
    }
  }
  
  # Rest of data is the sdu:s
  my $sizeOfHeaderInBytes = ($pduBitLengthBeforeHeader - length $pduBitData) / 8;
  $nrOfHeaders++;

  $pduAttributeNr = 1;
  my $headerNr = 0;
  while($headerNr < $nrOfHeaders)
  {
    $headerNr++;
    my $size = $payloadSize{$headerNr};
    if($size eq "")
    {
      # last payload (if not a control element)
      my $sizeInBytes = $signalDataLengthToUse - $sizeOfHeaderInBytes - $totalPayloadSizeFirstSdus;
      $size = $sizeInBytes * 8;
      $$decodedDataRef .= $compactOutput ? "LI (RLC SDU $nrOfHeaders) = $sizeInBytes" : "${intendentation}LI (RLC SDU $nrOfHeaders) = $sizeInBytes\n";
    }

    my $bitsLeft = length $pduBitData;
    if($bitsLeft > 0 && $bitsLeft < $size)
    {
      my $bits = getNextPduBits($decodedDataRef, $bitsLeft);
      my $hexData = binToHex($bits);
      $hexData =~ s/(..)/$1 /g;
      $$decodedDataRef .= $compactOutput ? "RLC SDU $headerNr = $hexData..." : "${intendentation}RLC SDU $headerNr = $hexData...\n";;
    }
    else
    {
      nextPduFieldHex($decodedDataRef, $level, $intendentation, "RLC SDU $headerNr", $size);
    }
  }
}

sub decodeRlcAmdPdu
{
  my ($decodedDataRef, $level, $intendentation, $type) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  my $pduBitLengthBeforeHeader = (length $pduBitData) + 1;

  my %values = (
    0 => "AMD PDU",
    1 => "AMD PDU segment",
  );
  my $RF = nextPduFieldMapBit($decodedDataRef, $level, $intendentation, "RF", 1, \%values);

  my %values = (
    0 => "Status report not requested",
    1 => "Status report requested",
  );
  my $P = nextPduFieldMapBit($decodedDataRef, $level, $intendentation, "P", 1, \%values);

  my %fi_values = (
    "00" => "First byte starts SDU, Last byte ends SDU",
    "01" => "First byte starts SDU, Last byte does NOT end SDU",
    "10" => "First byte does NOT start SDU, Last byte ends SDU",
    "11" => "First byte does NOT start SDU, Last byte does NOT end SDU",
  );
  my $FI = nextPduFieldMapBit($decodedDataRef, $level, $intendentation, "FI", 2, \%fi_values);

  my %values = (
    0 => "Data field follows from the octet following the fixed part of the header",
    1 => "A set of E field and LI field follows from the octet following the fixed part of the header",
  );
  my $E = nextPduFieldMapBit($decodedDataRef, $level, $intendentation, "E", 1, \%values);

  nextPduField($decodedDataRef, $level, $intendentation, "SN", 10);
  
  if($RF == 1)
  {
    # AMD PDU segment

    my %values = (
      0 => "Last byte of the AMD PDU segment does not correspond to the last byte of an AMD PDU",
      1 => "Last byte of the AMD PDU segment corresponds to the last byte of an AMD PDU",
    );
    my $LSF = nextPduFieldMapBit($decodedDataRef, $level, $intendentation, "LSF", 1, \%values);

    nextPduField($decodedDataRef, $level, $intendentation, "SO", 15);
  }

  my %payloadSize;
  my %payloadType;
  my $nrOfHeaders = 0;
  my $totalPayloadSizeFirstSdus = 0;
  
  if($E == 1)
  {
    # A set of E field and LI field follows
    while($E == 1)
    {
      my %values = (
        0 => "Data field follows from the octet following the LI field following this E field",
        1 => "A set of E field and LI field follows from the bit following the LI field following this E field",
      );
      $E = nextPduFieldMapBit($decodedDataRef, $level, $intendentation, "E", 1, \%values);

      $nrOfHeaders++;
      my $LI = nextPduField($decodedDataRef, $level, $intendentation, "LI (RLC SDU $nrOfHeaders)", 11);

      $payloadSize{$nrOfHeaders} = $LI * 8;  # in bits
      $totalPayloadSizeFirstSdus += $LI;     # in bytes
    }
    
    if($nrOfHeaders % 2 == 1)
    {
      # odd number of LI, 4 bits padding
      nextPduField($decodedDataRef, $level, $intendentation, "Padding", 4);
    }
  }
  
  # Rest of data is the sdu:s
  my $sizeOfHeaderInBytes = ($pduBitLengthBeforeHeader - length $pduBitData) / 8;
  $nrOfHeaders++;

  $pduAttributeNr = 1;
  my $headerNr = 0;
  while($headerNr < $nrOfHeaders)
  {
    $headerNr++;
    my $size = $payloadSize{$headerNr};
    if($size eq "")
    {
      # last payload (if not a control element)
      my $sizeInBytes = $signalDataLengthToUse - $sizeOfHeaderInBytes - $totalPayloadSizeFirstSdus;
      $size = $sizeInBytes * 8;
      $$decodedDataRef .= $compactOutput ? "LI (RLC SDU $nrOfHeaders) = $sizeInBytes" : "${intendentation}LI (RLC SDU $nrOfHeaders) = $sizeInBytes\n";
    }

    # Not possible to decode PDCP header
    my $bitsLeft = length $pduBitData;
    if($bitsLeft > 0 && $bitsLeft < $size)
    {
      my $bits = getNextPduBits($decodedDataRef, $bitsLeft);
      my $hexData = binToHex($bits);
      $hexData =~ s/(..)/$1 /g;
      $$decodedDataRef .= $compactOutput ? "RLC SDU $headerNr = $hexData..." : "${intendentation}RLC SDU $headerNr = $hexData...\n";;
    }
    elsif($bitsLeft == 0)
    {
      $$decodedDataRef .= $compactOutput ? "RLC SDU $headerNr = ..." : "${intendentation}RLC SDU $headerNr = ...\n";;
    }
    else
    {
      nextPduFieldHex($decodedDataRef, $level, $intendentation, "RLC SDU $headerNr", $size);
    }
  }
}


# ------------- Decode PDCP PDU -----------------------------------------------------------------------------------


sub decodePdcpPduFromHex
{

  my ($pduHexData, $level, $intendentation, $rohcMode, $snlength, $type) = @_;
  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  my $compactOutputNextLevel = ($level + 1) >= $settings{compactlevel} ? 1 : 0;
  my $savedPduBitData = $pduBitData;
  $pduBitData = hexToBin($pduHexData);

  my $decodedData = $compactOutput ? "PDCP PDU {" : "${intendentation}PDCP PDU {";
  $decodedData .= $compactOutputNextLevel ? " " : "\n";
  $decodedData .= decodePdcpPdu($level + 1, "$intendentation  ", $rohcMode, $snlength, $type);
  $decodedData .= $compactOutput ? " } " : "${intendentation}}\n";

  $pduBitData = $savedPduBitData;
  
  return $decodedData;
}


sub decodePdcpPdu
{
  my ($level, $intendentation, $rohcMode, $snlength, $type) = @_;  
  # expects pdu to be stored in global variable $pduBitData

  my $decodedData = "";

  if($type eq "DRB")
  {
    my %values = (
      0 => "Control PDU",
      1 => "Data PDU",
    );
    if($snlength == -1)
    {
      decodePdcpDataPdu(\$decodedData, $level, $intendentation, $rohcMode, $snlength);
    }
    elsif(nextPduFieldMapBit(\$decodedData, $level, $intendentation, "D/C", 1, \%values) == 0)
    {
      decodePdcpControlPdu(\$decodedData, $level, $intendentation);
    }
    else
    {
      # Assuming PDU with long SN (12 bits). PDU with short PDCP SN (7 bits) is not supported.
      decodePdcpDataPdu(\$decodedData, $level, $intendentation, $rohcMode, $snlength);
    }
  }
  else  # SRB
  {
    decodePdcpSrbPdu(\$decodedData, $level, $intendentation);
  }

  return $decodedData;  
}


sub decodePdcpControlPdu
{
  my ($decodedDataRef, $level, $intendentation) = @_;
  
  my %values = (
    "000" => "PDCP status report",
    "001" => "Interspersed ROHC feedback packet",
  );
  my $PDUType = nextPduFieldMapBit($decodedDataRef, $level, $intendentation, "PDU Type", 3, \%values);

  if($PDUType eq "000")
  {
    nextPduField($decodedDataRef, $level, $intendentation, "FMS", 12);
    nextPduFieldRestBit($decodedDataRef, $level, $intendentation, "Bitmap");
  }
  elsif($PDUType eq "001")
  {
    getNextPduBits($decodedDataRef, 4);
    decodeRohcFeedbackPacket($decodedDataRef, $level, $intendentation);
  }    

}

# decodeRohcFeedbackPacket based on RFC3095. Focus is profile 1. Only supports small cids. //ejohnni
sub decodeRohcFeedbackPacket
{
  my ($decodedDataRef, $level, $intendentation) = @_;

  if(peekNextPduBits($decodedDataRef, 5) ne "11110")
  {
    # Unknown packet type
    nextPduFieldRestHex($decodedDataRef, $level, $intendentation, "ROHC Packet");
    return;
  }
  getNextPduBits($decodedDataRef, 5);
  
  $$decodedDataRef .= "${intendentation}ROHC FEEDBACK PACKET\n";
  
  $intendentation .= "  ";

  my $code = nextPduField($decodedDataRef, $level, $intendentation, "ROHC Size", 3);
  my $size = $code;
  if($code == 0)
  {
    $size = nextPduField($decodedDataRef, $level, $intendentation, "ROHC Size", 8);
  }

  if(peekNextPduBits($decodedDataRef, 4) eq "1110")
  {
    # Add-cid octet is optional
    getNextPduBits($decodedDataRef, 4);
    nextPduField($decodedDataRef, $level, $intendentation, "ROHC CID", 4);
    $size = ($size - 1);
  }
  else
  {
    # Fake add so we get ROHC CID printed
    $pduBitData = "0" . $pduBitData;
    nextPduField($decodedDataRef, $level, $intendentation, "ROHC CID", 1);
  }
  
  if($size == 1)
  {
    # feedback-1
    $$decodedDataRef .= "${intendentation}  FEEDBACK-1\n";
    nextPduField($decodedDataRef, $level, $intendentation, "ROHC SN", 8);
  }
  else
  {
    # feedback-2
    $$decodedDataRef .= "${intendentation}  FEEDBACK-2\n";
    my %ack_values = (
      "00" => "ACK",
      "01" => "NACK",
      "10" => "Static-NACK",
      "11" => "Reserved",
    );
    my %mode_values = (
      "00" => "Reserved",
      "01" => "Unidirectional(U)",
      "10" => "Optimistic(O)",
      "11" => "Reliable(R)",
    );

    nextPduFieldMapBit($decodedDataRef, $level, $intendentation, "ROHC Feedback", 2, \%ack_values);
    nextPduFieldMapBit($decodedDataRef, $level, $intendentation, "ROHC Mode", 2, \%mode_values);
  
    nextPduField($decodedDataRef, $level, $intendentation, "ROHC SN", 12);
     
    $size = ($size - 2);
      
    my $optnum = 0;
    while($size > 0)
    {
      $optnum = ($optnum + 1);
      
      my %opt_values = (
        "0001" => "CRC",
        "0010" => "REJECT",
        "0011" => "SN-NOT-VALID",
        "0100" => "MORE-SN-DATA",
        "0101" => "CLOCK",
        "0110" => "MAX-JITTER",
        "0111" => "LOSS"
      );
      my $str_prefix = sprintf("ROHC Option%d ", $optnum);

      nextPduFieldMapBit($decodedDataRef, $level, $intendentation, $str_prefix . "Type", 4, \%opt_values);
      my $optlen = nextPduField($decodedDataRef, $level, $intendentation, $str_prefix . "Length", 4);
      $size = ($size - 1);
      nextPduFieldHex($decodedDataRef, $level, $intendentation, $str_prefix . "Data", (8 * $optlen));
      $size = ($size - $optlen);
    }    
  }
}

# decodeRohcIRPacket based on RFC3095. 
sub decodeRohcIRPacket
{
  my ($decodedDataRef, $level, $intendentation) = @_;

  getNextPduBits($decodedDataRef,7);

  my $hasDynamic = nextPduFieldBit($decodedDataRef, $level, $intendentation, "D-Chain", 1);
  
  my %profile_values = (
    0 => "Uncompressed IP",
    1 => "RTP/UDP/IP",
    2 => "UDP/IP",
    3 => "ESP/IP"
  );

  my $profile = nextPduFieldMap($decodedDataRef, $level, $intendentation, "Profile", 8, \%profile_values);
  nextPduFieldBit($decodedDataRef, $level, $intendentation, "CRC", 8);

  my $ipversion;
  if(peekNextPduBits($decodedDataRef, 4) eq "0100")
  {
    # ipV4
    $$decodedDataRef .= "${intendentation}IPv4 STATIC\n";
    $ipversion = 4;
    nextPduField($decodedDataRef, $level, $intendentation . " ", "Version", 4);
    getNextPduBits($decodedDataRef, 4);
    my %prot_values = (
      1 => "ICMP",
      6 => "TCP",
      17 => "UDP"
    );
    nextPduFieldMap($decodedDataRef, $level, $intendentation . " ", "Protocol", 8, \%prot_values);
    decodeIpAddress($decodedDataRef, $level, $intendentation . " ", "Source IP");
    decodeIpAddress($decodedDataRef, $level, $intendentation . " ", "Dest IP");
  }
  elsif(peekNextPduBits($decodedDataRef, 4) eq "0110")
  {
    # ipV6
    $$decodedDataRef .= "${intendentation}IPv6 STATIC\n";
    $ipversion = 6;
    nextPduField($decodedDataRef, $level, $intendentation . " ", "Version", 4);
    nextPduFieldBit($decodedDataRef, $level, $intendentation . " ", "Flow label", 20);
    nextPduFieldHex($decodedDataRef, $level, $intendentation . " ", "Next Header", 8);
    nextPduFieldHex($decodedDataRef, $level, $intendentation . " ", "Source", 16 * 8);
    nextPduFieldHex($decodedDataRef, $level, $intendentation . " ", "Dest", 16 * 8);
  }
  else
  {
    $$decodedDataRef .= "${intendentation}Unknown IP version\n";
    return;
  }
  if($profile != 1 && $profile != 2)
  {
    $$decodedDataRef .= "${intendentation}Only support of profile 1 & 2\n";
    return;
  }

  $$decodedDataRef .= "${intendentation}UDP STATIC\n";
  nextPduField($decodedDataRef, $level, $intendentation . " ", "Source Port", 2 * 8);
  nextPduField($decodedDataRef, $level, $intendentation . " ", "Dest Port", 2 * 8);

  if($profile == 1)
  {
    # RTP header
    $$decodedDataRef .= "${intendentation}RTP STATIC\n";
    nextPduFieldHex($decodedDataRef, $level, $intendentation . " ", "SSRC", 4 * 8);
  }

  if($hasDynamic == 0)
  {
    # no DYNAMIC info
    return;
  }

  if($ipversion == 4)
  {
    # ipV4
    $$decodedDataRef .= "${intendentation}IPv4 DYNAMIC\n";
    nextPduField($decodedDataRef, $level, $intendentation . " ", "Type of Service", 8);
    nextPduField($decodedDataRef, $level, $intendentation . " ", "Time to Live", 8);
    nextPduField($decodedDataRef, $level, $intendentation . " ", "Identification", 2 * 8);
    nextPduFieldBit($decodedDataRef, $level, $intendentation . " ", "DF", 1);
    nextPduFieldBit($decodedDataRef, $level, $intendentation . " ", "RND", 1);
    nextPduFieldBit($decodedDataRef, $level, $intendentation . " ", "NBO", 1);
    nextPduFieldBit($decodedDataRef, $level, $intendentation . " ", "Padding", 5);
    $$decodedDataRef .= "${intendentation} Generic extension header list\n";
    decodeRohcCompressedList($decodedDataRef, $level, $intendentation . "  ");
  }
  elsif($ipversion == 6)
  {
    # ipV6
    $$decodedDataRef .= "${intendentation}IPv6 DYNAMIC\n";
    nextPduField($decodedDataRef, $level, $intendentation . " ", "Traffic Class", 8);
    nextPduField($decodedDataRef, $level, $intendentation . " ", "Hop Limit", 8);
    $$decodedDataRef .= "${intendentation} Generic extension header list\n";
    decodeRohcCompressedList($decodedDataRef, $level, $intendentation . "  ");
  }

  $$decodedDataRef .= "${intendentation}UDP DYNAMIC\n";
  nextPduFieldHex($decodedDataRef, $level, $intendentation . " ", "Checksum", 2 * 8);

  if($profile == 1)
  {
    $$decodedDataRef .= "${intendentation}RTP DYNAMIC\n";
    nextPduField($decodedDataRef, $level, $intendentation . " ", "V(=2)", 2);
    nextPduField($decodedDataRef, $level, $intendentation . " ", "Padding (P)", 1);
    my $rx = getNextPduBits($decodedDataRef, 1);
    nextPduField($decodedDataRef, $level, $intendentation . " ", "CSRC count (CC)", 4);

    nextPduField($decodedDataRef, $level, $intendentation . " ", "Marker (M)", 1);

    my %pt_values = (
      0 => "Audio PCMU",
      1 => "Audio 1016",
      2 => "Audio G721",
      3 => "Audio GSM",
      5 => "Audio DVI4",
      6 => "Audio DVI4",
      7 => "Audio LPC",
      8 => "Audio PCMA",
      9 => "Audio G722",
      10 => "Audio L16",
      11 => "Audio L16",
      14 => "Audio MPA",
      15 => "Audio G728",
      25 => "Video CelB",
      26 => "Video JPEG",
      28 => "Video nv",
      31 => "Video H261",
      32 => "Video MPV",
      33 => "Audio/Video MP2T"
    );
    my $pt_idx;
    for($pt_idx = 96; $pt_idx < 128; $pt_idx = $pt_idx + 1)
    {
      $pt_values{$pt_idx} = "Dynamic";
    }
    nextPduFieldMap($decodedDataRef, $level, $intendentation . " ", "Payload Type(PT)", 7, \%pt_values);

    nextPduField($decodedDataRef, $level, $intendentation . " ", "RTP Seq No", 2 * 8);

    nextPduField($decodedDataRef, $level, $intendentation . " ", "RTP TS", 4 * 8);

    $$decodedDataRef .= "${intendentation} Generic CSRC list\n";
    decodeRohcCompressedList($decodedDataRef, $level, $intendentation . "  ");

    if($rx eq "1")
    {
      getNextPduBits($decodedDataRef, 3);
      nextPduFieldBit($decodedDataRef, $level, $intendentation . " ", "Extension (X)", 1);

      my %mode_values = (
        0 => "Reserved",
        1 => "Unidirectional",
        2 => "Bi-Optimistic",
        3 => "Bi-Reliable"
      );

      nextPduFieldMap($decodedDataRef, $level, $intendentation . " ", "Mode", 2, \%mode_values);
      my $tis = binToDec(getNextPduBits($decodedDataRef, 1));
      my $tss = binToDec(getNextPduBits($decodedDataRef, 1));
      
      if($tss)
      {
        decodeRohc456Value($decodedDataRef, $level, $intendentation . " ", "TS_Stride");
      }
      if($tis)
      {
        decodeRohc456Value($decodedDataRef, $level, $intendentation . " ", "Time_Stride");
      }
    }
  }
}

# decodeRohcIRDynPacket based on RFC3095. 
sub decodeRohcIRDynPacket
{
  my ($decodedDataRef, $level, $intendentation) = @_;

  getNextPduBits($decodedDataRef,8);

  my %profile_values = (
    0 => "Uncompressed IP",
    1 => "RTP/UDP/IP",
    2 => "UDP/IP",
    3 => "ESP/IP"
  );

  my $profile = nextPduFieldMap($decodedDataRef, $level, $intendentation, "Profile", 8, \%profile_values);
  nextPduFieldBit($decodedDataRef, $level, $intendentation, "CRC", 8);

  my $ipversion = 4;
  if($ipversion == 4)
  {
    # ipV4
    $$decodedDataRef .= "${intendentation}IPv4 DYNAMIC\n";
    nextPduField($decodedDataRef, $level, $intendentation . " ", "Type of Service", 8);
    nextPduField($decodedDataRef, $level, $intendentation . " ", "Time to Live", 8);
    nextPduField($decodedDataRef, $level, $intendentation . " ", "Identification", 2 * 8);
    nextPduFieldBit($decodedDataRef, $level, $intendentation . " ", "DF", 1);
    nextPduFieldBit($decodedDataRef, $level, $intendentation . " ", "RND", 1);
    nextPduFieldBit($decodedDataRef, $level, $intendentation . " ", "NBO", 1);
    nextPduFieldBit($decodedDataRef, $level, $intendentation . " ", "Padding", 5);
    $$decodedDataRef .= "${intendentation} Generic extension header list\n";
    decodeRohcCompressedList($decodedDataRef, $level, $intendentation . "  ");
  }
  elsif($ipversion == 6)
  {
    # ipV6
    $$decodedDataRef .= "${intendentation}IPv6 DYNAMIC\n";
    nextPduField($decodedDataRef, $level, $intendentation . " ", "Traffic Class", 8);
    nextPduField($decodedDataRef, $level, $intendentation . " ", "Hop Limit", 8);
    $$decodedDataRef .= "${intendentation} Generic extension header list\n";
    decodeRohcCompressedList($decodedDataRef, $level, $intendentation . "  ");
  }

  $$decodedDataRef .= "${intendentation}UDP DYNAMIC\n";
  nextPduFieldHex($decodedDataRef, $level, $intendentation . " ", "Checksum", 2 * 8);

  if($profile == 1)
  {
    $$decodedDataRef .= "${intendentation}RTP DYNAMIC\n";
    nextPduField($decodedDataRef, $level, $intendentation . " ", "V(=2)", 2);
    nextPduField($decodedDataRef, $level, $intendentation . " ", "Padding (P)", 1);
    my $rx = getNextPduBits($decodedDataRef, 1);
    nextPduField($decodedDataRef, $level, $intendentation . " ", "CSRC count (CC)", 4);

    nextPduField($decodedDataRef, $level, $intendentation . " ", "Marker (M)", 1);

    my %pt_values = (
      0 => "Audio PCMU",
      1 => "Audio 1016",
      2 => "Audio G721",
      3 => "Audio GSM",
      5 => "Audio DVI4",
      6 => "Audio DVI4",
      7 => "Audio LPC",
      8 => "Audio PCMA",
      9 => "Audio G722",
      10 => "Audio L16",
      11 => "Audio L16",
      14 => "Audio MPA",
      15 => "Audio G728",
      25 => "Video CelB",
      26 => "Video JPEG",
      28 => "Video nv",
      31 => "Video H261",
      32 => "Video MPV",
      33 => "Audio/Video MP2T"
    );
    my $pt_idx;
    for($pt_idx = 96; $pt_idx < 128; $pt_idx = $pt_idx + 1)
    {
      $pt_values{$pt_idx} = "Dynamic";
    }
    nextPduFieldMap($decodedDataRef, $level, $intendentation . " ", "Payload Type(PT)", 7, \%pt_values);

    nextPduField($decodedDataRef, $level, $intendentation . " ", "RTP Seq No", 2 * 8);

    nextPduField($decodedDataRef, $level, $intendentation . " ", "RTP TS", 4 * 8);

    $$decodedDataRef .= "${intendentation} Generic CSRV list\n";
    decodeRohcCompressedList($decodedDataRef, $level, $intendentation . "  ");

    if($rx eq "1")
    {
      getNextPduBits($decodedDataRef, 3);
      nextPduFieldBit($decodedDataRef, $level, $intendentation . " ", "Extension (X)", 1);

      my %mode_values = (
        0 => "Reserved",
        1 => "Unidirectional",
        2 => "Bi-Optimistic",
        3 => "Bi-Reliable"
      );

      nextPduFieldMap($decodedDataRef, $level, $intendentation . " ", "Mode", 2, \%mode_values);
      my $tis = binToDec(getNextPduBits($decodedDataRef, 1));
      my $tss = binToDec(getNextPduBits($decodedDataRef, 1));
      
      if($tss)
      {
        decodeRohc456Value($decodedDataRef, $level, $intendentation . " ", "TS_Stride");
      }
      if($tis)
      {
        decodeRohc456Value($decodedDataRef, $level, $intendentation . " ", "Time_Stride");
      }
    }
  }
}


# Decode a RFC3095 section 4.5.6 self-describing value
sub decodeRohc456Value
{
  my ($decodedDataRef, $level, $intendentation, $name) = @_;
  if(getNextPduBits($decodedDataRef, 1) eq "0")
  {
    nextPduField($decodedDataRef, $level, $intendentation, $name, 7);
  }
  elsif(getNextPduBits($decodedDataRef, 1) eq "0")
  {
    nextPduField($decodedDataRef, $level, $intendentation, $name, 14);
  }
  elsif(getNextPduBits($decodedDataRef, 1) eq "0")
  {
    nextPduField($decodedDataRef, $level, $intendentation, $name, 21);
  }
  else
  {
    nextPduField($decodedDataRef, $level, $intendentation, $name, 29);
  }
}  

# Decode a RFC3095 section 5.8.3 compressed list
sub decodeRohcCompressedList
{
  my ($decodedDataRef, $level, $intendentation) = @_;

  my $et = binToDec(getNextPduBits($decodedDataRef, 2));
  
  if($et == 0)
  {
    my $gp = binToDec(getNextPduBits($decodedDataRef, 1));
    my $ps = binToDec(getNextPduBits($decodedDataRef, 1));
    my $cc = binToDec(getNextPduBits($decodedDataRef, 4));
    if($gp)
    {
      nextPduFieldBit($decodedDataRef, $level, $intendentation, "gen_id", 8);
    }
    my $m = $cc;
    my $n = 0;
    my $at = 0;
    while($at < $m)
    {
      $at = $at + 1;
      my $prefix = sprintf(" Item %d ", $at);
      if(getNextPduBits($decodedDataRef, 1) == 1)
      {
        $n = $n + 1;
        $$decodedDataRef .= "${intendentation}" . $prefix . "see Value $n\n";
      }
      else
      {
        $$decodedDataRef .= "${intendentation}" . $prefix . "without Value\n";
      }
      if($ps == 0)
      {
        nextPduFieldBit($decodedDataRef, $level, $intendentation, $prefix . "Index", 3);
      }
      else
      {
        nextPduFieldBit($decodedDataRef, $level, $intendentation, $prefix . "Index", 7);
      }
    }
    if(($ps == 0) && ($m > 0) && ($m % 2 == 1))
    {
      nextPduFieldBit($decodedDataRef, $level, $intendentation, "Padding", 4);
    }
    $at = 0;
    while($at < $n)
    {
      $at = $at + 1;
      my $prefix = sprintf(" Value %d",$at);
      nextPduFieldHex($decodedDataRef, $level, $intendentation, $prefix, 8);
    }
  }
  else
  {
    $$decodedDataRef .= "${intendentation}Warning: ET = $et not supported\n";
  }
}


sub decodePdcpDataPdu
{
  
  my ($decodedDataRef, $level, $intendentation, $rohcMode, $snLength) = @_;

  if($snLength == -1)
  {
    # rohc without header
  }
  elsif($snLength == 7)
  {
    nextPduField($decodedDataRef, $level, $intendentation, "PDCP SN", 7);
  }
  else
  {
    nextPduFieldBit($decodedDataRef, $level, $intendentation, "Reserved bits", 3);
    nextPduField($decodedDataRef, $level, $intendentation, "PDCP SN", 12);
  }

  my $orig_intendentation = $intendentation;

  while($rohcMode == 1)
  {
    if(peekNextPduBits($decodedDataRef, 7) eq "1111110")
    {
      # ROHC IR PACKET
      $$decodedDataRef .= "${intendentation}ROHC IR PACKET\n";
      decodeRohcIRPacket($decodedDataRef, $level, $intendentation . "  ");
      $rohcMode = 0;
    }
    elsif(peekNextPduBits($decodedDataRef, 8) eq "11111000")
    {
      # ROHC IR-DYN PACKET
      $$decodedDataRef .= "${intendentation}ROHC IR-DYN PACKET\n";
      decodeRohcIRDynPacket($decodedDataRef, $level, $intendentation . "  ");
      $rohcMode = 0;
    }
    elsif(peekNextPduBits($decodedDataRef, 8) eq "11100000")
    {
      # Padding
      getNextPduBits($decodedDataRef, 8);
    }
    elsif(peekNextPduBits($decodedDataRef, 4) eq "1110")
    {
      # Add-cid
      getNextPduBits($decodedDataRef, 4);
      nextPduFieldBit($decodedDataRef, $level, $intendentation, "Add-cid", 4);
    }
    elsif(peekNextPduBits($decodedDataRef, 5) eq "11110")
    {
      decodeRohcFeedbackPacket($decodedDataRef, $level, $intendentation);
    }
    else
    {
      $intendentation .= "  ";
      $rohcMode = 0;
      my $extension=0;
      my $tbit;
      if(getNextPduBits($decodedDataRef,1) eq "0")
      {
        # UO-0
        $$decodedDataRef .= "${orig_intendentation}ROHC UO-0 PACKET\n";
        nextPduField($decodedDataRef, $level, $intendentation, "SN", 4);
        nextPduField($decodedDataRef, $level, $intendentation, "CRC", 3);
      }
      else
      {
        if(getNextPduBits($decodedDataRef,1) eq "0")
        {
          if(getNextPduBits($decodedDataRef,1) eq "0")
          {
            # UO-1-ID
            $tbit=0;
            $$decodedDataRef .= "${orig_intendentation}ROHC UO-1-ID PACKET\n";
            nextPduField($decodedDataRef, $level, $intendentation, "IP-ID", 5);
            $extension = nextPduField($decodedDataRef, $level, $intendentation, "Extension(X)", 1);
            nextPduField($decodedDataRef, $level, $intendentation, "SN", 4);
            nextPduField($decodedDataRef, $level, $intendentation, "CRC", 3);
          }
          else
          {
            # UO-1-TS
            $tbit=1;
            $$decodedDataRef .= "${orig_intendentation}ROHC UO-1-TS PACKET\n";
            nextPduField($decodedDataRef, $level, $intendentation, "TS", 5);
            nextPduField($decodedDataRef, $level, $intendentation, "RTP Marker(M)", 1);
            nextPduField($decodedDataRef, $level, $intendentation, "SN", 4);
            nextPduField($decodedDataRef, $level, $intendentation, "CRC", 3);
          }
        }
        else
        {
          getNextPduBits($decodedDataRef,1);
          if($settings{rohcprofile2})
          {
            $$decodedDataRef .= "${orig_intendentation}ROHC UOR-2 PACKET (PROFILE2)\n";
            nextPduField($decodedDataRef, $level, $intendentation, "SN", 5);
            $extension = nextPduField($decodedDataRef, $level, $intendentation, "Extension(X)", 1);
            nextPduField($decodedDataRef, $level, $intendentation, "CRC", 7);
          }
          else
          {
            if(peekNextPduBits($decodedDataRef,6) =~ /[01]*0$/) {
              $$decodedDataRef .= "${orig_intendentation}ROHC UOR-2-ID PACKET (PROFILE1)\n";
              nextPduField($decodedDataRef, $level, $intendentation, "IP-ID", 5);
              $extension = nextPduField($decodedDataRef, $level, $intendentation, "Extension(X)", 1);
              nextPduField($decodedDataRef, $level, $intendentation, "CRC", 7);
            }
            else
            {
              $$decodedDataRef .= "${orig_intendentation}ROHC UOR-2-TS PACKET (PROFILE1)\n";
              nextPduField($decodedDataRef, $level, $intendentation, "TS", 5);
              $tbit = nextPduField($decodedDataRef, $level, $intendentation, "T", 1);
              nextPduField($decodedDataRef, $level, $intendentation, "RTP Marker(M)", 1);
              nextPduField($decodedDataRef, $level, $intendentation, "SN", 6);
              $extension = nextPduField($decodedDataRef, $level, $intendentation, "Extension(X)", 1);
              nextPduField($decodedDataRef, $level, $intendentation, "CRC", 7);
            }
          }
        }
      }
      
      if($extension)
      {
        my $ext = nextPduField($decodedDataRef, $level, $intendentation, "Extension type", 2);
        $intendentation .= "  ";
        if($ext == 0)
        {
          nextPduField($decodedDataRef, $level, $intendentation, "SN", 3);
          if($tbit && !$settings{rohcprofile2})
          {
            nextPduField($decodedDataRef, $level, $intendentation, "TS", 3);
          }
          else
          {
            nextPduField($decodedDataRef, $level, $intendentation, "IP-ID", 3);
          }
        }
        elsif($ext == 1)
        {
          nextPduField($decodedDataRef, $level, $intendentation, "SN", 3);
          if($settings{rohcprofile2})
          {
            nextPduField($decodedDataRef, $level, $intendentation, "IP-ID", 11);
          }
          elsif($tbit)
          {
            nextPduField($decodedDataRef, $level, $intendentation, "TS", 3);
            nextPduField($decodedDataRef, $level, $intendentation, "IP-ID", 8);
          }
          else
          {
            nextPduField($decodedDataRef, $level, $intendentation, "IP-ID", 3);
            nextPduField($decodedDataRef, $level, $intendentation, "TS", 8);
          }
        }
        elsif($ext == 2)
        {
          nextPduField($decodedDataRef, $level, $intendentation, "SN", 3);
          if($settings{rohcprofile2})
          {
            nextPduField($decodedDataRef, $level, $intendentation, "IP-ID2", 11);
            nextPduField($decodedDataRef, $level, $intendentation, "IP-ID", 8);
          }
          elsif($tbit)
          {
            nextPduField($decodedDataRef, $level, $intendentation, "TS", 3+8);
            nextPduField($decodedDataRef, $level, $intendentation, "IP-ID", 8);
          }
          else
          {
            nextPduField($decodedDataRef, $level, $intendentation, "IP-ID", 3+8);
            nextPduField($decodedDataRef, $level, $intendentation, "TS", 8);
          }
        }
        elsif($ext == 3)
        {
          my $s = 0;
          my $i = 0;
          my $ip = 0;
          my $ip2 = 0;
          my $r_ts = 0;
          my $tsc = 0;
          my $rtp = 0;
          if($settings{rohcprofile2})
          {
            $s = nextPduField($decodedDataRef, $level, $intendentation, "S-bit", 1);
            nextPduField($decodedDataRef, $level, $intendentation, "Mode", 2);
            $i = nextPduField($decodedDataRef, $level, $intendentation, "I-bit", 1);
            $ip = nextPduField($decodedDataRef, $level, $intendentation, "ip-bit", 1);
            $ip2 = nextPduField($decodedDataRef, $level, $intendentation, "ip2-bit", 1);
          }
          else
          {
            $s = nextPduField($decodedDataRef, $level, $intendentation, "S-bit", 1);
            $r_ts = nextPduField($decodedDataRef, $level, $intendentation, "R-TS-bit", 1);
            $tsc = nextPduField($decodedDataRef, $level, $intendentation, "Tsc-bit", 1);
            $i = nextPduField($decodedDataRef, $level, $intendentation, "I-bit", 1);
            $ip = nextPduField($decodedDataRef, $level, $intendentation, "ip-bit", 1);
            $rtp = nextPduField($decodedDataRef, $level, $intendentation, "rtp-bit", 1);
          }
          my $tos = 0;
          my $ttl = 0;
          my $pr = 0;
          my $ipx = 0;

          if($r_ts)
          {
            if($tsc)
            {
              decodeRohc456Value($decodedDataRef, $level, $intendentation . " ", "TS (scaled)");
            }
            else
            {
              decodeRohc456Value($decodedDataRef, $level, $intendentation . " ", "TS (absolute)");
            }
          }

          if($ip)
          {
            $$decodedDataRef .= "${intendentation}INNER IP-FLAGS\n";
            $tos = nextPduField($decodedDataRef, $level, $intendentation . "  ", "TOS-bit", 1);
            $ttl = nextPduField($decodedDataRef, $level, $intendentation . "  ", "TTL-bit", 1);
            nextPduField($decodedDataRef, $level, $intendentation . "  ", "DF", 1);
            $pr = nextPduField($decodedDataRef, $level, $intendentation . "  ", "PR-bit", 1);
            $ipx = nextPduField($decodedDataRef, $level, $intendentation . "  ", "IPX-bit", 1);
            nextPduField($decodedDataRef, $level, $intendentation . "  ", "NBO", 1);
            nextPduField($decodedDataRef, $level, $intendentation . "  ", "RND", 1);
            if($settings{rohcprofile2})
            {
              nextPduField($decodedDataRef, $level, $intendentation . "  ", "Reserved(=0)", 1);
            }
            else
            {
              $ip2=nextPduField($decodedDataRef, $level, $intendentation . "  ", "ip2-bit", 1);
            }
          }
          
          if($ip)
          {
            $$decodedDataRef .= "${intendentation}INNER IP-HEADER\n";

            if($tos)
            {
              nextPduField($decodedDataRef, $level, $intendentation . "  ", "TOS", 8);
            }
            if($ttl)
            {
              nextPduField($decodedDataRef, $level, $intendentation . "  ", "TTL", 8);
            }
            if($pr)
            {
              nextPduField($decodedDataRef, $level, $intendentation . "  ", "PR", 8);
            }
          }


          
          if($i)
          {
            nextPduField($decodedDataRef, $level, $intendentation, "IP-ID", 16);
          }

        
        }

      
      }
    
    }
  }
  
  my $hexData = binToHex($pduBitData);
  $hexData =~ s/(..)/$1 /g;
  $$decodedDataRef .= "${orig_intendentation}Data = $hexData\n";
}





sub decodePdcpSrbPdu
{
  my ($decodedDataRef, $level, $intendentation) = @_;
  
  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
  $pduAttributeNr++;
  
  nextPduFieldBit($decodedDataRef, $level, $intendentation, "Reserved bits", 3);
  nextPduField($decodedDataRef, $level, $intendentation, "PDCP SN", 5);

  my $hexData = binToHex($pduBitData);
  $hexData =~ /(.*)(.{8})$/;
  my $Data = $1;
  my $MACI = $2;
  $Data =~ s/(..)/$1 /g;
  $MACI =~ s/(..)/$1 /g;

  if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
  $pduAttributeNr++;

  $$decodedDataRef .= $compactOutput ? "Data = $Data" : "${intendentation}Data = $Data\n";

  if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
  $pduAttributeNr++;

  $$decodedDataRef .= $compactOutput ? "MAC-I = $MACI" : "${intendentation}MAC-I = $MACI\n";
}


# ------------- Decode GTP-U -----------------------------------------------------------------------------------


sub decodeGtpuFromHex
{
  my ($pduHexData, $level, $intendentation, $type) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  my $compactOutputNextLevel = ($level + 1) >= $settings{compactlevel} ? 1 : 0;
  my $savedPduBitData = $pduBitData;
  $pduBitData = hexToBin($pduHexData);

  my $decodedData = $compactOutput ? "GTP-U {" : "${intendentation}GTP-U {";
  $decodedData .= $compactOutputNextLevel ? " " : "\n";
  $decodedData .= decodeGtpu($level + 1, "$intendentation  ", $type);
  $decodedData .= $compactOutput ? " } " : "${intendentation}}\n";

  $pduBitData = $savedPduBitData;
  
  return $decodedData;
}


sub decodeGtpu
{
  my ($level, $intendentation, $type) = @_;
  # expects data to be stored in global variable $pduBitData

  my $decodedData = "";

  if($signalTraceLine =~ /_Igtpu/)
  {
    # 22 bytes before gtpu data starts
    my $bitsBeforeGtpuStarts = getNextPduBits(\$decodedData, 22 * 8);
  }

  nextPduField(\$decodedData, $level, $intendentation, "Version", 3);
  nextPduField(\$decodedData, $level, $intendentation, "PT", 1);
  nextPduField(\$decodedData, $level, $intendentation, "(*)", 1);
  my %values = (
    "0" => "Next Extension Header field either is not present or, if present, shall not be interpreted",
    "1" => "Next Extension Header field is present, and shall be interpreted",
  );
  my $E = nextPduFieldMapBit(\$decodedData, $level, $intendentation, "E", 1, \%values);
  my %values = (
    "0" => "Sequence Number field either is not present or, if present, shall not be interpreted",
    "1" => "Sequence Number field is present, and shall be interpreted",
  );
  my $S = nextPduFieldMapBit(\$decodedData, $level, $intendentation, "S", 1, \%values);
  my %values = (
    "0" => "N-PDU Number field either is not present, or, if present, shall not be interpreted",
    "1" => "N-PDU Number field is present, and shall be interpreted",
  );
  my $PN = nextPduFieldMapBit(\$decodedData, $level, $intendentation, "PN", 1, \%values);
  decodeGtpuMessageType(\$decodedData, $level, $intendentation);
  my $Length = nextPduField(\$decodedData, $level, $intendentation, "Length", 16);
  nextPduField(\$decodedData, $level, $intendentation, "Tunnel Endpoint Identifier", 32);
  if($S)
  {
    nextPduField(\$decodedData, $level, $intendentation, "Sequence Number", 16);
  }
  if($PN)
  {
    nextPduField(\$decodedData, $level, $intendentation, "N-PDU", 8);
  }
  if($E || $S || $PN)
  {
    # This field is present if and only if any one or more of the S, PN and E flags are set.
    nextPduField(\$decodedData, $level, $intendentation, "Next Extension Type", 8);
  }

  return $decodedData;  
}


sub decodeGtpuMessageType
{
  my ($decodedDataRef, $level, $intendentation) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
  $pduAttributeNr++;

  my $bits = getNextPduBits($decodedDataRef, 8);
  my $value = binToDec($bits);
  my %values = (
    "1" => "Echo Reuest",
    "2" => "Echo Response",
    "26" => "Error Indication",
    "31" => "Supported Extension Headers Notificication",
    "254" => "End Marker",
    "255" => "G-PDU",
  );
  my $valueName = "";
  if(defined $values{$value})
  {
    $valueName = $values{$value};
  }
  elsif($value >= 3 && $value <= 25)
  {
    $valueName = "Reserved in 3GPP TS 32.295 and 3GPP TS 29.060";
  }
  elsif(($value >= 27 && $value <= 30) || ($value >= 32 && $value <= 253))
  {
    $valueName = "Reserved in 3GPP TS 29.060";
  }
  else
  {
    $valueName = "INVALID VALUE";
  }
  $$decodedDataRef .= $compactOutput ? "Message Type = $valueName ($value)" : "${intendentation}Message Type = $valueName ($value)\n";
}


# ------------- Decode SCTP -----------------------------------------------------------------------------------


sub decodeSctpFromHex
{
  my ($pduHexData, $level, $intendentation, $type) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  my $compactOutputNextLevel = ($level + 1) >= $settings{compactlevel} ? 1 : 0;
  my $savedPduBitData = $pduBitData;
  $pduBitData = hexToBin($pduHexData);

  my $decodedData = $compactOutput ? "SCTP {" : "${intendentation}SCTP {";
  $decodedData .= $compactOutputNextLevel ? " " : "\n";
  $decodedData .= decodeSctp($level + 1, "$intendentation  ", $type);
  $decodedData .= $compactOutput ? " } " : "${intendentation}}\n";

  $pduBitData = $savedPduBitData;
  
  return $decodedData;
}


sub decodeSctp
{
  my ($level, $intendentation, $type) = @_;
  # expects data to be stored in global variable $pduBitData

  my $decodedData = "";

  nextPduField(\$decodedData, $level, $intendentation, "Source port", 16);
  nextPduField(\$decodedData, $level, $intendentation, "Destination port", 16);
  nextPduField(\$decodedData, $level, $intendentation, "Verification tag", 32);
  nextPduField(\$decodedData, $level, $intendentation, "Checksum", 32);

  my %values = (
    0 => "DATA - Payload Data",
    1 => "INIT - Initiation",
    2 => "INIT ACK - Initiation Acknowledgement",
    3 => "SACK - Selective Acknowledgement",
    4 => "HEARTBEAT - Heartbeat Request",
    5 => "HEARTBEAT ACK - Heartbeat Acknowledgement",
    6 => "ABORT",
    7 => "SHUTDOWN",
    8 => "SHUTDOWN ACK - Shutdown Acknowledgement",
    9 => "ERROR - Operation Error",
    10 => "COOKIE ECHO - State Cookie",
    11 => "COOKIE ACK - Cookie Acknowledgement",
    12 => "ECNE - Reserved for Explicit Congestion Notification Echo",
    13 => "CWR - Reserved for Congestion Window Reduced",
    14 => "SHUTDOWN COMPLETE - Shutdown Complete",
    63 => "IETF-defined Chunk Extensions",
    127 => "IETF-defined Chunk Extensions",
    191 => "IETF-defined Chunk Extensions",
    255 => "IETF-defined Chunk Extensions",
  );
  
  while($pduBitData ne "")
  {
    my $lengthBeforeChunk = length $pduBitData;

    my $type = nextPduFieldMap(\$decodedData, $level, $intendentation, "Type", 8, \%values);
    nextPduField(\$decodedData, $level, $intendentation, "Flags", 8);
    my $chunkLengthInBytes = nextPduField(\$decodedData, $level, $intendentation, "Length", 16);
  
    if($type == 4 || $type == 5)
    {
      decodeSctpCppHeartbeat(\$decodedData, $level, $intendentation);
    }
    
    my $lengthAfterChunk = length $pduBitData;
    if(($lengthBeforeChunk - $lengthAfterChunk) < $chunkLengthInBytes * 8)
    {
      substr $pduBitData, 0, ($chunkLengthInBytes * 8 - ($lengthBeforeChunk - $lengthAfterChunk)), "";
    }
  }
  
  return $decodedData;  
}


sub decodeSctpCppHeartbeat
{
  my ($decodedDataRef, $level, $intendentation) = @_;

  my $tempPduBitData = $pduBitData;
  my $unknownData = getNextPduBits($decodedDataRef, 8 * 8);
  decodeIpAddress($decodedDataRef, $level, $intendentation, "IP address 1 (heartbeat format 1)");
  my $unknownData2 = getNextPduBits($decodedDataRef, 16 * 8);
  decodeIpAddress($decodedDataRef, $level, $intendentation, "IP address 2 (heartbeat format 1)");

  $pduBitData = $tempPduBitData;
  my $unknownData = getNextPduBits($decodedDataRef, 16 * 8);
  decodeIpAddress($decodedDataRef, $level, $intendentation, "IP address 1 (heartbeat format 2)");
  my $unknownData2 = getNextPduBits($decodedDataRef, 16 * 8);
  decodeIpAddress($decodedDataRef, $level, $intendentation, "IP address 2 (heartbeat format 2)");
}


# ------------- Decode IP -----------------------------------------------------------------------------------


sub decodeIpFromHex
{
  my ($pduHexData, $level, $intendentation, $type) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  my $compactOutputNextLevel = ($level + 1) >= $settings{compactlevel} ? 1 : 0;
  my $savedPduBitData = $pduBitData;
  $pduBitData = hexToBin($pduHexData);

  my $decodedData = $compactOutput ? "IP {" : "${intendentation}IP {";
  $decodedData .= $compactOutputNextLevel ? " " : "\n";
  $decodedData .= decodeIp($level + 1, "$intendentation  ", $type);
  $decodedData .= $compactOutput ? " } " : "${intendentation}}\n";

  $pduBitData = $savedPduBitData;
  
  return $decodedData;
}


sub decodeIp
{
  my ($level, $intendentation, $type) = @_;
  # expects packet to be stored in global variable $pduBitData

  my $pduBitLengthBefore = length $pduBitData;

  my $decodedData = "";
  nextPduField(\$decodedData, $level, $intendentation, "Version", 4);
  my $IHL = nextPduField(\$decodedData, $level, $intendentation, "IHL", 4);
  nextPduField(\$decodedData, $level, $intendentation, "Differential services", 8);
  nextPduField(\$decodedData, $level, $intendentation, "Total length", 16);
  nextPduField(\$decodedData, $level, $intendentation, "Identification", 16);
  nextPduField(\$decodedData, $level, $intendentation, "Flags", 3);
  nextPduField(\$decodedData, $level, $intendentation, "Fragment offset", 13);
  nextPduField(\$decodedData, $level, $intendentation, "TTL", 8);
  my $protocol = decodeIpProtocol(\$decodedData, $level, $intendentation);
  nextPduField(\$decodedData, $level, $intendentation, "Header checksum", 16);
  decodeIpAddress(\$decodedData, $level, $intendentation, "Source IP address");
  decodeIpAddress(\$decodedData, $level, $intendentation, "Destination IP address");

  my $pduBitLengthAfter = length $pduBitData;
  my $pduBitsUsed = $pduBitLengthBefore - $pduBitLengthAfter;
  if($pduBitsUsed < ($IHL * 32))
  {
    my $bitsOptionsAndPadding = getNextPduBits(\$decodedData, $IHL * 32 - $pduBitsUsed);
    my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
    if($compactOutput && $pduAttributeNr > 1) {$decodedData .= ", ";}
    $pduAttributeNr++;
    $decodedData .= $compactOutput ? "Options and padding = 0b$bitsOptionsAndPadding" : "${intendentation}Options and padding = 0b$bitsOptionsAndPadding\n";
  }
  
  if($protocol == 6)
  {
    decodeTcpFromBits(\$decodedData, $level, $intendentation);
  }
  elsif($protocol == 17)
  {
    decodeUdpFromBits(\$decodedData, $level, $intendentation);
  }

  return $decodedData;  
}


sub decodeIpProtocol
{
  my ($decodedDataRef, $level, $intendentation) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
  $pduAttributeNr++;

  my $bits = getNextPduBits($decodedDataRef, 8);
  my $value = binToDec($bits);
  my %values = (
    "6" => "TCP",
    "17" => "UDP",
  );
  my $valueName = "";
  if(defined $values{$value})
  {
    $valueName = $values{$value};
  }
  else
  {
    $valueName = "Unknown";
  }
  $$decodedDataRef .= $compactOutput ? "Protocol = $valueName ($value)" : "${intendentation}Message Type = $valueName ($value)\n";
  
  return $value;
}


sub decodeIpAddress
{
  my ($decodedDataRef, $level, $intendentation, $attributeName) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
  $pduAttributeNr++;

  my $address1 = binToDec(getNextPduBits($decodedDataRef, 8));
  my $address2 = binToDec(getNextPduBits($decodedDataRef, 8));
  my $address3 = binToDec(getNextPduBits($decodedDataRef, 8));
  my $address4 = binToDec(getNextPduBits($decodedDataRef, 8));

  $$decodedDataRef .= $compactOutput ? "$attributeName = $address1.$address2.$address3.$address4" : "${intendentation}$attributeName = $address1.$address2.$address3.$address4\n";
}


sub decodeUdpFromBits
{
  my ($decodedDataRef, $level, $intendentation) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  my $compactOutputNextLevel = ($level + 1) >= $settings{compactlevel} ? 1 : 0;

  $$decodedDataRef .= $compactOutput ? "UDP {" : "${intendentation}UDP {";
  $$decodedDataRef .= $compactOutputNextLevel ? " " : "\n";
  decodeUdp($decodedDataRef, $level + 1, "$intendentation  ");
  $$decodedDataRef .= $compactOutput ? " } " : "${intendentation}}\n";
}


sub decodeUdp
{
  my ($decodedDataRef, $level, $intendentation) = @_;

  nextPduField($decodedDataRef, $level, $intendentation, "Source port", 16);
  nextPduField($decodedDataRef, $level, $intendentation, "Destination port", 16);
  my $length = nextPduField($decodedDataRef, $level, $intendentation, "Length", 16);
  nextPduField($decodedDataRef, $level, $intendentation, "Checksum", 16);

  my $size = ($length - 8) * 8;
  my $bitsLeft = length $pduBitData;
  if($bitsLeft > 0 && $bitsLeft < $size)
  {
    my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
    if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
    $pduAttributeNr++;

    my $bits = getNextPduBits($decodedDataRef, $bitsLeft);
    my $hexData = binToHex($bits);
    $hexData =~ s/(..)/$1 /g;
    $$decodedDataRef .= $compactOutput ? "Data = $hexData..." : "${intendentation}Data = $hexData...\n";;
  }
  else
  {
    nextPduFieldHex($decodedDataRef, $level, $intendentation, "Data", $size);
  }
}


sub decodeTcpFromBits
{
  my ($decodedDataRef, $level, $intendentation) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  my $compactOutputNextLevel = ($level + 1) >= $settings{compactlevel} ? 1 : 0;

  $$decodedDataRef .= $compactOutput ? "TCP {" : "${intendentation}TCP {";
  $$decodedDataRef .= $compactOutputNextLevel ? " " : "\n";
  decodeTcp($decodedDataRef, $level + 1, "$intendentation  ");
  $$decodedDataRef .= $compactOutput ? " } " : "${intendentation}}\n";
}


sub decodeTcp
{
  my ($decodedDataRef, $level, $intendentation) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  my $pduBitLengthBefore = length $pduBitData;

  nextPduField($decodedDataRef, $level, $intendentation, "Source port", 16);
  nextPduField($decodedDataRef, $level, $intendentation, "Destination port", 16);
  nextPduField($decodedDataRef, $level, $intendentation, "Sequence number", 32);
  nextPduField($decodedDataRef, $level, $intendentation, "Acknowledge number", 32);
  my $dataOffset = nextPduField($decodedDataRef, $level, $intendentation, "Data offset", 4);
  nextPduField($decodedDataRef, $level, $intendentation, "Reserved", 4);
  #nextPduFieldBit($decodedDataRef, $level, $intendentation, "Flags", 8);
  nextPduFieldBit($decodedDataRef, $level, $intendentation, "CWR", 1);
  nextPduFieldBit($decodedDataRef, $level, $intendentation, "ECE", 1);
  nextPduFieldBit($decodedDataRef, $level, $intendentation, "URG", 1);
  nextPduFieldBit($decodedDataRef, $level, $intendentation, "ACK", 1);
  nextPduFieldBit($decodedDataRef, $level, $intendentation, "PSH", 1);
  nextPduFieldBit($decodedDataRef, $level, $intendentation, "RST", 1);
  nextPduFieldBit($decodedDataRef, $level, $intendentation, "SYN", 1);
  nextPduFieldBit($decodedDataRef, $level, $intendentation, "FIN", 1);
  nextPduField($decodedDataRef, $level, $intendentation, "Window size", 16);
  nextPduField($decodedDataRef, $level, $intendentation, "Checksum", 16);
  nextPduField($decodedDataRef, $level, $intendentation, "Urgent pointer", 16);

  my $pduBitLengthAfter = length $pduBitData;
  my $pduBitsUsed = $pduBitLengthBefore - $pduBitLengthAfter;
  if($pduBitsUsed < ($dataOffset * 32))
  {
    my $bitsOptionsAndPadding = getNextPduBits($decodedDataRef, $dataOffset * 32 - $pduBitsUsed);
    if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
    $pduAttributeNr++;
    $$decodedDataRef .= $compactOutput ? "Options and padding = 0b$bitsOptionsAndPadding" : "${intendentation}Options and padding = 0b$bitsOptionsAndPadding\n";
  }

  #my $size = ($length - 8) * 8;
  #my $bitsLeft = length $pduBitData;
  #if($bitsLeft > 0 && $bitsLeft < $size)
  #{
  #  if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
  #  $pduAttributeNr++;
  #
  #  my $bits = getNextPduBits($decodedDataRef, $bitsLeft);
  #  my $hexData = binToHex($bits);
  #  $hexData =~ s/(..)/$1 /g;
  #  $$decodedDataRef .= $compactOutput ? "Data = $hexData..." : "${intendentation}Data = $hexData...\n";;
  #}
  #else
  #{
  #  nextPduFieldHex($decodedDataRef, $level, $intendentation, "Data", $size);
  #}
}


# ------------- PDU Common -------------------------------------------------------------------------------------


sub nextPduField
{
  my ($decodedDataRef, $level, $intendentation, $name, $nrOfBits) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
  $pduAttributeNr++;
  
  my $bits = getNextPduBits($decodedDataRef, $nrOfBits);
  my $value = binToDec($bits);
  $$decodedDataRef .= $compactOutput ? "$name = $value" : "$intendentation$name = $value\n";

  return $value;
}


sub nextPduFieldBit
{
  my ($decodedDataRef, $level, $intendentation, $name, $nrOfBits) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
  $pduAttributeNr++;
  
  my $bits = getNextPduBits($decodedDataRef, $nrOfBits);
  $$decodedDataRef .= $compactOutput ? "$name = $bits" : "$intendentation$name = $bits\n";

  return $bits;
}


sub nextPduFieldHex
{
  my ($decodedDataRef, $level, $intendentation, $name, $nrOfBits) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
  $pduAttributeNr++;
  
  my $bits = getNextPduBits($decodedDataRef, $nrOfBits);
  my $hexData = binToHex($bits);
  $hexData =~ s/(..)/$1 /g;
  $$decodedDataRef .= $compactOutput ? "$name = $hexData" : "$intendentation$name = $hexData\n";

  return $hexData;
}


sub nextPduFieldRestBit
{
  my ($decodedDataRef, $level, $intendentation, $name) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
  $pduAttributeNr++;
  
  my $bits = $pduBitData;
  $pduBitData = "";

  if($bits eq "")
  {
    $$decodedDataRef .= $compactOutput ? "$name = (empty)" : "$intendentation$name = (empty)\n";
  }
  else
  {
    $$decodedDataRef .= $compactOutput ? "$name = $bits" : "$intendentation$name = $bits\n";
  }

  return $bits;
}


sub nextPduFieldRestHex
{
  my ($decodedDataRef, $level, $intendentation, $name) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
  $pduAttributeNr++;
  
  my $bits = $pduBitData;
  $pduBitData = "";
  my $hexData = "";

  if($bits eq "")
  {
    $$decodedDataRef .= $compactOutput ? "$name = (empty)" : "$intendentation$name = (empty)\n";
  }
  else
  {
    $hexData = binToHex($bits);
    $$decodedDataRef .= $compactOutput ? "$name = $hexData" : "$intendentation$name = $hexData\n";
  }

  return $hexData;
}


sub nextPduFieldMap
{
  my ($decodedDataRef, $level, $intendentation, $name, $nrOfBits, $valueMapRef) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
  $pduAttributeNr++;
  
  my $bits = getNextPduBits($decodedDataRef, $nrOfBits);
  my $value = binToDec($bits);
  my $valueName = $valueMapRef->{$value};
  if(defined $valueName)
  {
    $$decodedDataRef .= $compactOutput ? "$name = $value ($valueName)" : "$intendentation$name = $value ($valueName)\n";
  }
  else
  {
    $$decodedDataRef .= $compactOutput ? "$name = $value (INVALID VALUE)" : "$intendentation$name = $value (INVALID VALUE)\n";
  }
  
  return $value;
}


sub nextPduFieldMapBit
{
  my ($decodedDataRef, $level, $intendentation, $name, $nrOfBits, $valueMapRef) = @_;

  my $compactOutput = $level >= $settings{compactlevel} ? 1 : 0;
  if($compactOutput && $pduAttributeNr > 1) {$$decodedDataRef .= ", ";}
  $pduAttributeNr++;
  
  my $bits = getNextPduBits($decodedDataRef, $nrOfBits);
  my $valueName = $valueMapRef->{$bits};
  if(defined $valueName)
  {
    $$decodedDataRef .= $compactOutput ? "$name = $bits ($valueName)" : "$intendentation$name = $bits ($valueName)\n";
  }
  else
  {
    $$decodedDataRef .= $compactOutput ? "$name = $bits (INVALID VALUE)" : "$intendentation$name = $bits (INVALID VALUE)\n";
  }
  
  return $bits;
}


sub peekNextPduBits
{
  my ($decodedDataRef, $nrOfBits) = @_;

  # read next byte from the signal data
  if((length $pduBitData) >= $nrOfBits)
  {
    return substr $pduBitData, 0, $nrOfBits;
  }
  else
  {
    return "";
  }
}


sub getNextPduBits
{
  my ($decodedDataRef, $nrOfBits) = @_;

  # read next byte from the signal data
  if((length $pduBitData) >= $nrOfBits)
  {
    return substr $pduBitData, 0, $nrOfBits, "";
  }
  
  if(!$signalDataEmptyWarningDisplayed)
  {
    $signalDataEmptyWarningDisplayed = 1;
    $$decodedDataRef .= "Decoder warning: No more pdu bits found to decode\n";
    $pduBitData = "";
  }
  
  return "";
}


sub hexToBin
{
  unpack("B*", pack("H*", shift));
}


sub binToHex
{
  unpack("H*", pack("B*", shift));
}


sub binToDec
{
  unpack("N", pack("B32", substr("0" x 32 . shift, -32)));
}


# ------------- Generate stand-alone version --------------------------------------------------------------


sub generateStandAloneVersion
{
  my $scriptLocation = $0;

  # read original script
  my $generatedScript;
  my $fileSize = -s $scriptLocation;
  open(FI, "<$scriptLocation") or die "Could not read file $scriptLocation";
  read FI, $generatedScript, $fileSize;

  # read cache
  my $cacheData;
  my $fileSize = -s $settings{cachepath};
  open(FI, "<$settings{cachepath}") or die "Could not read file $settings{cachepath}";
  read FI, $cacheData, $fileSize;

  # set settings for standaloneversion
  my $replaceCodeSettings = "  \$settings{standalone} = 1;";
  $generatedScript =~ s/\n  \# <standalone replace settings start>.*?<standalone replace settings end>/\n$replaceCodeSettings/s;

  # replace reading cache with read cache
  my $replaceCodeCache = "\$cacheData = <<__END__;\n$cacheData\n__END__\n";
  $generatedScript =~ s/\n  \# <standalone replace cache start>.*?<standalone replace cache end>/\n$replaceCodeCache/s;
  
  # save generated script
  open(FO, ">$settings{generate}") or die "Could not save file $settings{generate}";
  print FO $generatedScript;
  close FO;
  
  # make script executable
  `chmod 755 $settings{generate}`;
}


# ------------- Script arguments handling -----------------------------------------------------------------


# Copied from /vobs/erbs/ext/tools/perlLib/General/Shell.pm (to make the script completely stand-alone):


# Save script arguments. Typically code:
# saveArguments(@ARGV);
sub saveArguments
{
  @arguments = @_;
}

# Returns true if a flag is set, minimumLengthGiven is optional if flag can be
# given without writing the whole flag name
sub isFlagSet
{
  my ($flag, $minimumLengthGiven) = @_;
  $minimumLengthGiven = length $flag unless defined $minimumLengthGiven;
  
  my $argNr = 0;
  foreach my $argument (@arguments)
  {
    if (length $argument >= ($minimumLengthGiven + 1) &&
           $argument eq "-".(substr $flag, 0, ((length $argument) - 1)))
    {
      $argumentUsed[$argNr] = 1;
      return 1;
    }
    $argNr++;
  }

  return 0;
}

# Returns true if a flag is set, minimumLengthGiven is optional if flag can be
# given without writing the whole flag name. Will NOT update argumentUsed.
sub isFlagPresent
{
  my ($flag, $minimumLengthGiven) = @_;
  $minimumLengthGiven = length $flag unless defined $minimumLengthGiven;
  
  my $argNr = 0;
  foreach my $argument (@arguments){
    if(length $argument >= ($minimumLengthGiven + 1) &&
       $argument eq "-".(substr $flag, 0, ((length $argument) - 1))){
      return 1;
    }
  }
  return 0;
}


# Returns the value for a flag, empty if not found
sub getFlagValue
{
  my ($flag, $minimumLengthGiven) = @_;
  $minimumLengthGiven = length $flag unless defined $minimumLengthGiven;

  my $lastArgument = "";  
  my $argNr = 0;
  foreach my $argument (@arguments)
  {
    if ($argument =~ /^-$flag(.+)/ &&
        !$argumentUsed[$argNr])
    {
      $argumentUsed[$argNr] = 1;
      return $1;
    }
    elsif (length $lastArgument >= ($minimumLengthGiven + 1) &&
           $lastArgument eq "-".(substr $flag, 0, ((length $lastArgument) - 1)) &&
           $argument !~ /^-/ &&
	   !$argumentUsed[$argNr] &&
	   !$argumentUsed[($argNr - 1)])
    {
      $argumentUsed[$argNr] = 1;
      $argumentUsed[($argNr - 1)] = 1;
      return $argument;
    }

    $lastArgument = $argument;
    $argNr++;
  }

  return "";
}

# Returns the next argument that is not a flag, empty if not found
sub getNextNonFlagArgument
{
  my $argNr = 0;
  foreach my $argument (@arguments)
  {
    if ($argument !~ /^-/ && !$argumentUsed[$argNr])
    {
      $argumentUsed[$argNr] = 1;
      return $argument;
    }
    $argNr++;
  }

  return "";
}


# Returns the next arguments that are not flags, empty if no one found
sub getNextNonFlagArguments
{
  my @allArguments;

  my $argNr = 0;
  foreach my $argument (@arguments)
  {
    if ($argument !~ /^-/ && !$argumentUsed[$argNr])
    {
      $argumentUsed[$argNr] = 1;
      push @allArguments, $argument;
    }
    $argNr++;
  }

  return join(" ", @allArguments);
}


# Returns true if all given arguments have been used
sub isAllArgumentsUsed
{
  my $argNr = 0;
  foreach my $argument (@arguments)
  {
    if (!$argumentUsed[$argNr])
    {
      return 0;
    }
    $argNr++;
  }
  return 1;
}


# Returns all arguments that were not used (typically faulty arguments)
sub getUnusedArguments
{
  my @allArguments;

  my $argNr = 0;
  foreach my $argument (@arguments)
  {
    if (!$argumentUsed[$argNr])
    {
      push @allArguments, $argument;
    }
    $argNr++;
  }

  return join(" ", @allArguments);
}


# ------------- Usage ------------------------------------------------------------------------------------


sub printUsage
{
  if($settings{standalone})
  {
    print <<_END_;
Note! This is a standalone version of the decode script that only can decode traces and data for the upgrade package it was generated for.

_END_
  }
  else
  {
    print <<_END_;
Note! For a correct decoding your config spec should match the upgrade package that produced the trace and you should also update the
decode cache with the -u flag.

_END_
  }

  print <<_END_;
Decodes:
 - LPP send and receive bus traces. Note that TET.pl must be run on the log first.
 - Time stamps in LPP traces. Note that TET.pl must be run on the log first.
 - MAC, RLC and PDCP PDU traces
 - NC send and receive bus traces. Some BBMC send and receive bus traces.
 - CDA ziplog entries to show signal names and decoded CM memory (ziplog_verbose)
 - Data for any known struct using interactive mode or the node's coli command 'readcm'
 - RDR measurements (only when if model is used as input)

Usage: decode [options] [file...]

If files are passed as arguments the output will be saved in new files. If the file is named trace.log the output will
be put in trace_decoded.log. If no files are passed stdin will be decoded to stdout.

_END_

  if(!$settings{standalone})
  {
    print <<_END_;
Update options:
  -u/pdate           Update cache that holds information about the signals and structs that exist (always do this after
                     you have modified your config spec / have new interface model file)
  -f/orce            Force update to rebuild all parts
  -c/files           When updating the cache, also read structs in c-files. Needed for interactive decoding if the
                     struct to decode is located in a c-file. To be used together with the -update flag

_END_
  }

  print <<_END_;
Display options:
  -t/ype             Show data type for each attribute
  -l/evel <level>    Show compact output starting on level <level>. With levels means how nestled the attribute is in
                     different structs (also seen on the line intendentation). Default level is 4.
  -noc/ompress       Do not compress arrays of numbers (e.g. [0, 1, 2, 3]). Default compression is used.
  -not/ime           Do not decode radio time stamp. Default radio time stamp is decoded.
  -a/ll              Show all array elements, also those that are not used (only applicable for some structs)
  -hex               Show encoded hex data also for decoded signals
  -p/osition         Show position in memory for each attribute in both byte and word (useful if you use mtd peek).
  -pad/ding          Show padding and dummy attributes named padding0, padding1, dummy.. etc. These are normally hidden.

Interactive options:
  -i/nteractive      Encode data interactively
  -s/truct           Name of the struct to use to decode the data. To be used together with either the -interactive flag or
                     when decoding data retrieved with the node's coli command 'readcm'

Other options:
_END_

  if(!$settings{standalone})
  {
    print <<_END_;
  -g/enerate <file>  Generate a stand-alone version of the script that includes the cache. Save in file <file>.
  -if <path>         Path to where interface model xml files ($settings{ifmodelpath} and $settings{mtdpath_dul3} or
                     $settings{mtdpath_dus41}) are located. These files can be downloaded from the node and must belong
		     to the version of the software that has generated the traces. With this option no files need to be
		     read from the source code vobs.
_END_
  }
  
  print <<_END_;
  -csv               Save signal data in .csv files, one file for each type of signal struct that is found in the trace log
  -text              Print signal data in text format with all data on a single line. To make it easy to post-process
  -textonly          Same as -text but no other output
  -d/ct2000 <file>   Save MAC and RLC PDUs in DCT2000 format (that can be opened in Wireshark). Save in file <file>.out.
  -debug             Print debug data
  -h/elp             Show this help

Examples:
  cat trace.log | TET.pl | decode > trace_decoded.log
_END_

  if(!$settings{standalone})
  {
    print <<_END_;
  cat trace.log | TET.pl | decode -u > trace_decoded.log
_END_
  }
  
  print <<_END_;
  cat GCPUdump1024-01.dump | decode > GCPUdump1024-01_decoded.dump
  decode trace.log (if trace.log is already decoded with TET.pl)
  decode -if . trace.log
  decode *.dump
  decode -i -s DLMACPE_pdcchIndS
  decode -csv trace.log (if trace.log is already decoded with TET.pl)
  decode -d trace.log trace.log (if trace.log is already decoded with TET.pl, dct2000 file will be saved in trace.log.out)
_END_
}
